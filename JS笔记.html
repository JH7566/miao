JavaScript

=== 严格相等
!== 不严格相等

x || y 如果x转换为boolean为true,则整个表达式求值结果为x,否则为y

x && y 如果x转换为boolean为true,则整个表达式求值结果为y,否则为x


A || B || C || D
从左往右反回第一个为truthy的值,如果都没有,就返回D

A && B && C && D
从左往右返回第一个falsy的值,如果都没有,就返回D

truthy: 转换为boolean后为true的值
falsy: 转换为boolean后为false的值

a ?? b 左边为空(null/undefined)返回右边

non-null operator非空运算符




当一行的第一个字符是
+，-，/，[，(，`这几
个符号时，它前面一行
必须加分号。
更多的时候，人们直接
把分号置于本行的首部
（分号前置）：
;(2+8)



Math.sqrt(delta)

token 词元
代码中不可再分割的单词或连续的符号,如
for count && >= ( )


Math.ceil 向上取整
Math.floor 向下取整
Math.sin/cos/tan
Math.round 四舍五入
Math.trunc 保留整数部分
Math.pow(2, 5) 二的五次方
Math.log(100) 以e为底,100的对数

Math.sign 返回一个数的符号,正的返回1,负的返回-1,0返回0
Math.random() 返回一个0到1之间的随机数

sqrt

x = 13 /* 以十进制表示一个数 */
x = 0b1101 /* 以二进制表示一个数,前导0b */
x = 0xd /* 以十六进制进制表示一个数,前导为0x hexdecimal*/
x = 0000015 /* 以八进制表示一个数,前导0 */
x = 0o000015 /* 以八进制表示一个数,前导0o octet */






函数

函数看见的是自己定义位置周围的变量，叫词法作用域
函数看见的是自己调用位置周围的变量，叫“动态作用域”

定义位置只有一处，是确定的
但调用位置可以是很多处

var declaration hoist
变量声明提前


var f

var foo = function () {
var a = 2
f = function () {
return a * a
}
}

foo()

var bar = function() {
var a = 3

console.log( f() )
}

bar()



控制台为了让一份代码能够重复的在里面执行，允许不同次运行的代码用let重复声明变量，即以下代码：
let a = 2
console.log(a * a)
可以在控制台重复运行，即使第一次已运行已经用let声明变量a

目的是为了方便开发者在控制粘贴代码以调试或测试


let的重复声明是在代码运行之前就检查的，称静态分析
对let声明变量的说是在代码运行的时候
let声明的变量在块级作用域内
let声明的变量在声明完成之前是不能访问的，称为TDZ，Temper Dead Zone，暂时性死区
即使外层作用域有同名变量，也访问不到外层的那个变量



/*
是一个变量声明及初始化
等号后面的function...是**表达式**，称函数表达式，并不会在函数体的结束花括号后面自动结束
函数表达式的function关键字的后面可以出现函数名也可以不出现
就算它出现了函数名，这个函数名也只能在该函数内部使用
没有提前的效果，在这行之前不能使用到这个函数
*/


var square = function () {}



/*
当function关键字在一条**语句**的开头时，是一条语句，而不是表达式（在前面的语句都已经结束的情况下）
所以当它直接出现在控制台的时候，没有求值结果，因为它是一条语句，语句是没有求值结果的
它会在函数体的结束花括号的位置就结束这条语句，可以理解为函数声明的最后总有一个分号
所以不能在函数声明后面立刻用括号调用它
函数声明语句中，function关键字的后面必须要有函数的名字，而且此名字相当于声明了一个变量
函数声明会提前，提前到所在作用域的最前面，所以该作用域内的代码都可以调用该函数
*/
function square() {}

调用栈的两个含义：
计算机中存储函数间调用关系及每个函数每次运行时要返回的位置 的 实际存储空间

函数间相互调用形成的等待关系
function itob(x, base = 10) {
var result = ''
do {
var g = x % base
result = digitToChar(g) + result
x = (x - g) / base
} while (x > 0)
return result
}
function digitToChar(digit) {
if (digit < 10) { return String.fromCharCode(digit + 48) } else { return String.fromCharCode(digit + 65 - 10) } }
  输出数字的几进制模式 function itob(x, base=10) { var result='' do { var g=x % base result=digitToChar(g) + result x=(x - g) /
  base } while (x> 0)
  return result
  }


  function digitToChar(digit) {
  if (digit < 10) { return String.fromCharCode(digit + 48) } else { return String.fromCharCode(digit + 65 - 10) } }
    辗转相除法 <script>

    function icm(a,b){
    var x
    do {
    x = a % b
    a = b
    b = x
    }while(x !== 0)
    return a
    }


    </script>


    辗转相减法

    <script>

      function icm(a, b) {
        var x
        do {
          x = a - b
          a = b
          b = x
        } while (a !== b)
        return a
      }


    </script>

    if (x==0 || x ==1) {
    return x;
    }
    for (let i=0; i<=x;i++){ if (i*i<=x && (i+1)*(i+1)>x){
      return i;



      var mySqrt = function (x) {
      let left = 0
      let right = x
      while (left <= right) { let mid=left + ((right - left)>> 1)//中间位置索引 x>>1 表示除以2并取整，缩小一下遍历的范围
        if (mid * mid <= x) { left=mid + 1 } else { right=mid - 1 } } return right }; 二分法求根号n <script>

          function sqrt(n){
          var l = 0
          var r = n
          while(r - l > 0.0000000.1){根据结果的小数部位改变
          var x = (l + r) / 2
          if(x * x > n){
          r = x
          }else if(x * x < n){ l=x }else{ return x } } return (l + r) / 2 } </script>


            牛顿迭代法求根号n
            function sqrt(n) {
            var x = n
            var lastX = x

            if (n < 0) { return NaN } if (n==0) { return 0 } while (true) { x=(n / x + x) / 2 if (x===lastX) { break }
              lastX=x } return x } 作者：wi2ardly-margulisjw8
              链接：https://leetcode.cn/problems/base-7/solution/7jin-zhi-shu-by-wi2ardly-margulisjw8-x75w/ 来源：力扣（LeetCode）
              著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 narcissistic: 输入一个数，判断是否是水仙花数 narcissistics: 输出10000以内的水仙花数 palindrom:
              输入一个数，判断它数是否是回文数，如1223221 complete-number: 输入一个数，判断它是否是完全数（自行查相关概念） function isCompleteNumber(n) { var
              factorSum=0 var stop=Math.sqrt(n) for (var i=1; i < stop; i++) { if (n % i==0) { // 如果i是因子，那么n/i是其对应的因子
              factorSum +=i + n / i } } if (Number.isInteger(stop)) { factorSum +=stop } return factorSum==n } complete
              - numbers: 输出1000以内的完全数 for (var i=1; i <=1000; i++) { if (isCompleteNumber(n)) { console.log(i) } }
              prime: 输入一个数，判断它是否是素数 function isPrime(n) { var stop=Math.sqrt(n) for (var i=2; i <=stop; i++) { if (n %
              i==0) { return false } } return true } primes: 输出100以内的素数 itob:
              给定一个整数，将其转换为字符串：不能使用String等现成函数，但可以使用非此功能的其它函数，也不能利用任意运算符的自动类型转换 function itob(x) { var result='' do { var
              g=x % 10 result=digitToChar(g) + result x=(x - g) / 10 } while (x> 0)
              }
              function digitToChar(digit) {
              if (digit < 10) { return String.fromCharCode(digit + 48) } else { return String.fromCharCode(digit + 65) }
                } lcf & lcm: 输入两个数，输出它们的最大公约数和最小公倍数 function largestCommonFactor(a, b) { var c do { c=a % b a=b b=c }
                while (c !==0) return b } function largestCommonFactor(a, b) { while (a !==b) { if (a < b) { var t=a a=b
                b=t } var c=a - b a=b b=c } return a } function GCD(a, b) { while(a==b) { if (a> b) a -= b;
                else b -= a;
                }
                return a;
                }

                sqrt: 输入一个数，求它的平方根，精确到小数点后3位，不能使用Math.sqrt

                function sqrt(n) {
                for (var i = 1; i < n; i +=0.00001) { if (Math.abs(i * i - n) < 0.001) { return i } } } // 二分法 function
                  sqrt(n) { var left=0 var right=n while (right - left> 0.00000000001) {
                  var mid = (left + right) / 2
                  if (mid * mid > n) {
                  right = mid
                  } else if (mid * mid < n) { left=mid } else { return mid } } return (left + right) / 2 } function
                    sqrt(n) { var x=n for (var i=0; i < 30; i++) { x=(n / x + x) / 2 } return x } weekday:
                    输入年份与月份，输出这个月的第一天是周几（视具体设定，周一可以用1或0表示） function getMonth天数(y, month) { if (month==2) { if (y %
                    400==0 || y % 100 !==0 && y % 4==0) { return 29 } else { return 28 } } else { switch (month) { case
                    1: case 3: case 5: case 7: case 8: case 10: case 12: return 31 default: return 30 } } } function
                    weekday(year, month) { var daySum=0 for (var i=1; i < year; i++) { if (i % 400==0 || i % 100 !==0 &&
                    i % 4==0) { daySum +=366 } else { daySum +=365 } } for (var m=1; m < month; m++) { daySum
                    +=getMonth天数(year, m) } return (daySum + 1) % 7 } function weekday2(year, month) { var y=year - 1
                    var daySum=y * 365 + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) for (var m=1; m <
                    month; m++) { daySum +=getMonth天数(year, m) } return (daySum + 1) % 7 } 闭包 函数与变量都“属于”某个作用域
                    函数声明语句在哪个作用域运行，声明出来的函数就属于哪个作用域 变量声明语句在哪个作用域运行，声明出来的变量就属性哪个作用域
                    函数运行时会创建作用域，函数自身在哪个作用域，其运行创建的作用域就在哪个作用域内部 函数的参数及内部声明的变量及创建的函数都是在它这一次运行产生的作用域内部
                    如果函数运行返回了其在内部创建的函数，则其这次运行产生的作用域可能不会销毁 有函数声明语句才叫“创建了函数” 递归 求阶乘 <script>
                    function fact(n){
                    if(n == 1){
                    return 1
                    }else{
                    return n * fact(n - 1)
                    }
                    }
                    </script>


                    欧几里得算法求最大公约数

                    ***1.
                    function g(a,b){
                    if(a % b == 0){
                    return b
                    }else{
                    return g(b , a % b)
                    }
                    }


                    ***2.
                    <script>
                      function g(a, b) {
                        if (a == b) {
                          return a
                        } else if (a > b) {
                          return g(b, a - b)
                        } else {
                          return g(a, b - a)
                        }
                      }

                    </script>


                    斐波那契数列

                    <script>
                      function fibb(n) {
                        if (n < 3) {
                          return 1
                        } else {
                          return fibb(n - 1) + fibb(n - 2)
                        }
                      }




                      0
                      1


                      调用栈
                      a函数在运行时调用b函数，b函数运行过程中又调用c函数
                      类似这种形成的等待关系，类似于查字典
                      一种概念，计算机中一个存储该信息的实际位置
                      所有语言都有的
                      闭包
                      一个函数返回了其内部创建的函数
                      因这个被返回的函数还有机会运行，而这个函数在返回之前如果运行是可读到外层函数里的变量的
                      那么它稍后运行也应该能够读到这些变量
                      于是这些变量不能销毁，进而这些变量所在作用域（也是这个函数这一次运行时创建的作用域）也就不能销毁
                      js语言有，不少其它语言是没有此功能 / 概念的，因为它不能在一个函数内部创建一个函数并返回
                      一个作用域，一个维持变量存在的“域”
                      递归
                      一个函数直接或间接调用自身
                      递归过程会形成调用栈，正常来说不会形成闭包
                      所有有语言都有
                      是调用关系的一种特殊情况





数组 Array
                      数组是值的有序集合
                      数组本身也是一个值
                      var array = [] // 创建一个空数组
                      var array = [2, 3, 5, -8, 7, 6, 9, 0] // 创建一个非空数组
                      array.length可以得到数组的长度
                      值在数组内是有序存放的，每个值被指定了一个编号 / 下标 / 索引，是从0开始编号的
                      所以第一个值的编号为0，最后一个值的编号为array.length - 1
                      array.push(5) // 向数组末尾增加元素
                      array.push(4, 1, 8) // 可以一次性增加多个
                      push返回的是数组新的长度
                      array.pop() // 是将数组最后一个元素从数组中删除并返回
                      array.unshift() // 同push，只是从开头向数组增加元素
                      array.shift() // 同pop，只是从开头删除并返回一个元素

                      数组元素的计取
                      array[用于计算出索引的表达式]
                      array[5] 读取到数组下标为5的元素，即第六项
                      array[x + 3] 读取到数组下标为5的元素，即第六项
                      array[Math.max(1, 2, 3)] 读取到数组下标为3的元素
                      如果数组没有那么长，则读到undefined
                      array.at(index) 返回数组的第index项
                      array.at(-1) 返回倒数第一项
                      array.at(-array.length) 返回第一项
                      array[i] 的形式不能倒着访问

                      数组元素的修改
                      array[5] = 32423 // 将数组的第5项修改为某个值
                      array.at(5) = 2 // 语法错误


                      嵌套数组：
                      array = [[1, 2, 3], [4, 5, 6]]
                      array[0] 得到[1, 2, 3]这个数组
                      array[1] 得到[4, 5, 6]这个数组

                      array[1][1] = 8
                      array[1]

                      array = [2, 3, 5, 7, 1, 0, 9]

                      array[array[2]]  将得到0，先计算array[2]，为5，再取array[5] 得到0

                      数组的长度length
                      修改数组的长度将会将超出长度以外的元素全部抛弃

                      array.splice(i, amount, replacement1, replacement2, ...)
                      从数组的第i项开始，删除amount项，替换为后续的参数，返回被删除的项组成的数组

                      array.slice(start = 0, end = array.length)用数组start（包含）到end（不包含end）之间的元素创建一个新的数组并返回
                      不修改原数组，而是返回创建的新的子数组


                      array.fill(5) 将数组的所有位置上都填为5，返回的是数组本身
                      array.fill(5, 6, 10) 将数组第6（包含）到10（不包含）项都填为5

                      a = []
                      a.length = 8
                      a.fill(0)

                      a = Array(8).fill(0)


                      value.x 总是访问value的名为‘x’的属性
                      value[x] 是将[]内的表达计算出来，将计算结果做为要访问的属性名
                      此时[]内的x是表达式


                      数组是值的有序集合，在数组里，我们对值进行编号
                      对象是值的具名集合，在对象里，我们对值进行命名



                        // 逗号表达式,即在表达式上下文中，由逗号连接多个表达式,形成一个表达式
                        // 逗号表达式的求值结果为最后一个表达式的值
                        (1, 2, 3, 4, 5) + 5


                      console.log((1, 2, 3, 4, 5), 2)



                      属性访问运算符放在等号左边是改变它自身箭头的指向位置
                      放在等号右边或是用在其它表达式中是取到它的箭头指向的目标



                      很多语言里，基本数据类型如数值，字符串和布尔是不能读取属性的
                      在这样的语言里，只有真正的“对象”才可以读取出属性
                      所以在很多语言里，能读出属性，就肯定是对象，或者说，只有对象能读出属性

                      而在js里面，原始数据类型（primitive values）也可以读出属性以及调用方法
                      所以从这个角度讲，js中的一切（除underined，null）皆对象
                      但是原始数据类型在js中也不是真正的对象，所以并不能像真正的对象一样使用，如添加属性
                      对象本身占用和的空间是比较大的
                      而原始数据类型如number，实际上在js中只占8个字节，所以并没有空间来存储其它的属性信息
                      但为什么又能读出属性？因为
                      x = 2
                      x.toString()
                      被转换为这样的方式执行
                      Object(x).toString()
                      Object函数可以将原始数据类型转换为真正的对象
                      真正的对象当然可以读出属性，调用方法，添加属性
“对象”，Object，东西，事物




                      // 剩余参数必须在参数列表的最后
                      // 剩余参数只能有一个
                      // 剩余参数不能有默认值
                      // 与arguments的区别：是个真正的数组，可以自行起名字而不必一定要叫arguments
                      function foo(a, b = 3, ...c) { // rest parameter 剩余参数
                        c.push('x')
                        console.log(a, b, c)
                      }



                      function foo(a, b, ...c) { // rest parameter 剩余参数

                      }

                      var b = [1, 2, ...c, 3, ...d] // spread operator 展开运算符

                      var [a, b, ...c] = [1, 2, 3, 4, 5, 6] // rest element 剩余元素解构

                      35. 搜索插入位置
                      11111.

                      let l = 0, r = nums.length - 1, ans = nums.length;

                      while (l <= r) {
                        const mid = l + Math.floor((r - l) >> 1);

                        if (target > nums[mid]) {
                          l = mid + 1;
                        } else {
                          ans = mid;
                          r = mid - 1;
                        }
                      }

                      return ans;


                      222220.25turnvar searchInsert = function (nums, target) {
                        const n = nums.length;
                        let left = 0, right = n - 1, ans = n;
                        while (left <= right) {
                          let mid = ((right - left) >> 1) + left;
                          if (target <= nums[mid]) {
                            ans = mid;
                            right = mid - 1;
                          } else {
                            left = mid + 1;
                          }
                        }
                        return ans;
                      };
                      35. 搜索插入位置




                      var { a: A = 3, b = 5, ...c } = { a: 1, b: 2, c: 3, d: 4, e: 5 }  // 剩余元素解构

                      var obj1 = { a: 1, b: 2, c: 3 }
                      var obj2 = { x: 1, y: 2, z: 3 }
                      var obj3 = {
                        foo: 1,
                        bar: 2,
                        ...obj1, // object spread
                        ...obj2, // object spread
                      }








                      var obj = {
                        foo: foo,
                        bar: bar,
                      }
                      // 等价于
                      var obj = {
                        foo,
                        bar,
                      }





                        .



                      var a = 23423423

                      function random() {
                        var result = +String(a).slice(2, 6)

                        a = result * result

                        return result
                      }

                      平方取中法计算伪随机数







                      var a = 1664525
                      var c = 1013904223
                      var m = 256
                      var x = 100

                      function random() {
                        return x = (a * x + c) % m
                      }

                      线性同余法计算伪随机数



                      var random = function () {
                        var a = 1664525
                        var c = 1013904223
                        var m = 256
                        var x = 100

                        return function random() {
                          return x = (a * x + c) % m
                        }
                      }()




                      每个作用域其实是一个特殊对象，该作用域里的每个变量都是该对象的一个属性
                      所以全局作用域当然也是个对象，每个全局变量也都是全局作用对象的一个属性



                      由于最早的时候js只运行在浏览器中，
                      所以全局作用域对象真名为window（因为以前整个页面是活一个窗口中的）
                      而现在js可以运行在很多环境下，依然拿window做为全局作用域对象的名字就不太合适了，
                      所以标准给了的新的名字，叫globalThis，所有能够运行js代码的环境都可以通过这个全局变量来访问到全局作用域对象



求 x 的 n 次方

                        ** 1.

                      function myPow(x, n) {
                        if (n == 0) {
                          return 1
                        }
                        if (n < 0) {
                          return 1 / myPow(x, -n)
                        }

                        var result = 1
                        var xx = x
                        var e = 1

                        while (n > 0) {
                          if (e * 2 > n) { // 如果再自乘一次次方就大于我们需要的了
                            result *= xx
                            n = n - e // 已经将x的e次方累乘到结果中了，就从n次方中去掉e次方
                            xx = x // 重新变回x的1次方
                            e = 1 // e要同时发生变化
                            continue
                          }
                          xx = xx * xx // xx代表x的e次方
                          e = e * 2
                        }
                        return result
                      }


** 2.

                      function myPow(x, n) {
                        if (n == 0) {
                          return 1
                        }
                        if (n < 0) {
                          return 1 / myPow(x, -n)
                        }

                        if (n == 1) {
                          return x
                        }

                        if (n % 2 == 0) {
                          var t = myPow(x, n / 2)
                          return t * t
                        } else {
                          var t = myPow(x, (n - 1) / 2)
                          return t * t * x
                        }
                      }


** 3.


                      var mySqrt = function (x) {
                        if (x < 2) {
                          return x
                        }
                        var l = 0
                        var h = x

                        while (h - l > 1) {
                          var mid = Math.floor((l + h) / 2)
                          if (mid * mid > x) {
                            h = mid
                          } else if (mid * mid < x) {
                            l = mid
                          } else if (mid * mid == x) {
                            return mid
                          }
                        }

                        return l
                      };




                      function foo(x, ary) {
                        var a = ''
                        for (var i = 0; i < ary.length; i++) {
                          if (ary[i] == x) {
                            a += i
                          }
                        }
                        return a + ','
                      }








                      function foo(x, ary) {
                        var a = ''
                        for (var i = 0; i < ary.length; i++) {
                          if (ary[i] == x) {
                            a += i + ','
                          }
                        }
                        return a
                      }
                      /**
                       * @param {string} num1
                       * @param {string} num2
                       * @return {string}
                       */
                      var multiply = function (num1, num2) { // 32984723 , 23400234
                        var num1xn = []
                        var t = '0'
                        // 计算num1乘以0到9的每一个的结果，以方便后续查找
                        for (var i = 0; i < 10; i++) {
                          num1xn.push(t)
                          t = addStrings(t, num1)
                        }
                        var result = '0'
                        for (var j = num2.length - 1, zeros = 0; j >= 0; j--, zeros++) {
                          var p = num2[j] // 依次取出num2的最右边的每一位数
                          var product = num1xn[p] // 直接在num1xn数组里就能取到num1乘以p的值
                          // 如果p为'0',则无需
                          if (product !== '0') {
                            product = product + '0'.repeat(zeros)
                          }
                          result = addStrings(result, product)
                        }
                        return result
                      };


                      var addStrings = function (a, b) {
                        var carry = 0
                        var result = ''
                        for (var i = a.length - 1, j = b.length - 1; i >= 0 || j >= 0; i--, j--) {
                          var x = a[i] ? +a[i] : 0
                          var y = b[j] ? +b[j] : 0

                          var z = x + y + carry
                          var left = z % 10
                          carry = (z - left) / 10
                          result = left + result
                        }
                        if (carry) {
                          result = carry + result
                        }
                        return result
                      };






                      字符串相乘

                      /**
                       * @param {string} num1
                       * @param {string} num2
                       * @return {string}
                       */
                      var multiply = function (num1, num2) { // 32984723 , 23400234
                        var num1xn = []
                        var t = '0'
                        // 计算num1乘以0到9的每一个的结果，以方便后续查找
                        for (var i = 0; i < 10; i++) {
                          num1xn.push(t)
                          t = addStrings(t, num1)
                        }
                        var result = '0'
                        for (var j = num2.length - 1, zeros = 0; j >= 0; j--, zeros++) {
                          var p = num2[j] // 依次取出num2的最右边的每一位数
                          var product = num1xn[p] // 直接在num1xn数组里就能取到num1乘以p的值
                          // 如果p为'0',则无需
                          if (product !== '0') {
                            product = product + '0'.repeat(zeros)
                          }
                          result = addStrings(result, product)
                        }
                        return result
                      };

                      字符串相加
                      var addStrings = function (a, b) {
                        var carry = 0
                        var result = ''
                        for (var i = a.length - 1, j = b.length - 1; i >= 0 || j >= 0; i--, j--) {
                          var x = a[i] ? +a[i] : 0
                          var y = b[j] ? +b[j] : 0

                          var z = x + y + carry
                          var left = z % 10
                          carry = (z - left) / 10
                          result = left + result
                        }
                        if (carry) {
                          result = carry + result
                        }
                        return result
                      };

两数之和.1 题解



                      var twoSum = function (nums, target) {
                        var map = {} // 记录我们已经见到的数在原数组的哪个位置

                        for (var i = 0; i < nums.length; i++) {
                          var see = nums[i]
                          var need = target - see
                          if (need in map) {
                            return [i, map[need]]
                          }
                          map[see] = i // 记录我们已经遍历的数的位置
                        }
                      };



两数之和.2 题解

                      var twoSum = function (numbers, target) {
                        var i = 0
                        var j = numbers.length - 1
                        while (i < j) {
                          if (numbers[i] + numbers[j] > target) {
                            j--
                          } else if (numbers[i] + numbers[j] < target) {
                            i++
                          } else {
                            return [i + 1, j + 1]
                          }
                        }
                      };





                      BigInt
                      es2018开始支持的高精度整数运算
                      直接量写法：在一个整数后面加上一个n

                      非直接量写法：BigInt('982347928374929384729')
                      非直接量写法：BigInt(str)
                      注意不要这样写： BigInt(234234234244224243423242442342423423242324)

                      它是一个原始类型 / 基本类型
                      typeof 23094n === 'bigint'
                      BigInt只能跟BigInt运算，不能跟任何其它类型混合运算
                      Number(bigintnumber)可以将一个bigint类型转换为number
                      BigInt(number)则可以把普通整数转换为bigint类型
                      Math对象上的一各种函数并不能计算bigint



                      33Integer.reverse(nInteger.reverse(n8.
/**
 * @param {number} n
 * @return {number[]}
 */
 var countBits = function (n) {
                        var result = [0]
                        var sub = 1
                        for (var i = 1; i <= n; i++) {
                          // i的最高位1被减去
                          result.push(result[i - sub] + 1)

                          if ((i + 1) == (sub << 1)) {
                            sub *= 2
                          }
                        }
                        return result
                      };

                      var countBits = function (n) {
                        var result = [0]
                        for (var i = 1; i <= n; i++) {
                          // result[i & (i - 1)] 在result中查询i中最低位1变0后那个数中1的个数
                          result.push(result[i & (i - 1)] + 1)
                        }
                        return result
                      };





                      二进制里的1数量

                      /**
                       * @param {number} n - a positive integer
                       * @return {number}
                       */
                      var hammingWeight = function (n) {
                        var c = 0
                        for (var i = 0; i < 32; i++) {
                          if (n & 1) {
                            c++
                          }
                          n = n >> 1
                        }
                        return c
                      };

                      var hammingWeight = function (n) {
                        var c = 0
                        while (n) {
                          n = n & (n - 1)
                          c++
                        }
                        return c
                      };


                      位运算


                        & 与	两个位都为1时，结果才为1
                          | 或	两个位都为0时，结果才为0
                            ^ 异或	两个位相同为0，相异为1
                      ~取反	0变1，1变0
                        << 左移	各二进位全部左移若干位，高位丢弃，低位补0
                          >> 右移	各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）



                      n & (n - 1)将二进制最后一个1变成0




                      var reverseBits = function (n) {
                        let res = 0;
                        for (let i = 0; i < 32; i++) {
                          //res左移，然后取n的最低位，加到res的最低位
                          res = (res << 1) + (n & 1);
                          //n右移
                          n = n >> 1;
                        }
                        //把符号位换成0
                        return res >>> 0;
                      };




                      var reverseBits = function (n) {
                        let res = 0;
                        for (let i = 0; i < 32; i++) {
                          res = (res << 1) + (n & 1);
                          n = n >>> 1;
                        }

                        return res >>> 0;
                      };


                      function reverseBits(n) {
                        let ret = 0;
                        for (let i = 0; i < 32; i++) {
                          ret <<= 1;
                          ret += (n & 1);
                          n >>= 1;
                        }
                        return ret >>> 0;
                      }




















                      nums.length




 ## 按位与的知识

                      n & (n - 1)作用：将n的二进制表示中的最低位为1的改为0，先看一个简单的例子：
                      n = 10100(二进制），则(n - 1) = 10011 ==》n & (n - 1) = 10000
可以看到原本最低位为1的那位变为0。
                        弄明白了n & (n - 1)的作用，那它有哪些应用？

                        ------------------------------------------------------------------------------------------------------


                      1、 判断一个数是否是2的方幂
n > 0 && ((n & (n - 1)) == 0)

解释((n & (n - 1)) == 0)：

                        如果A & B == 0，表示A与B的二进制形式没有在同一个位置都为1的时候。

                        那么本题到底啥意思？？

                        不妨先看下n - 1是什么意思。

                        令: n = 1101011000(二进制, 十进制也一样)，则

    n - 1=1101010111。

                        n & (n - 1)=1101010000

由此可以得出，n和n - 1的低位不一样，直到有个转折点，就是借位的那个点，从这个点开始的高位，n和n - 1都一样，如果高位一样这就造成一个问题，就是n和n - 1在相同的位上可能会有同一个1，从而使((n & (n - 1)) != 0), 如果想要

                        ((n & (n - 1)) == 0)，则高位必须全为0，这样就没有相同的1。

                        所以n是2的幂或0

2. 求某一个数的二进制表示中1的个数
while (n > 0) {
                        count++;
                        n &= (n - 1);
                      }

                      3. 计算N!的质因数2的个数。
                      容易得出N!质因数2的个数 = [N / 2] + [N / 4] + [N / 8] + ....
                      下面通过一个简单的例子来推导一下过程：N = 10101(二进制表示）
                        现在我们跟踪最高位的1，不考虑其他位假定为0，
                        则在
                        [N / 2]    01000
                      [N / 4]    00100
                      [N / 8]    00010
                      [N / 8]    00001
则所有相加等于01111 = 10000 - 1
由此推及其他位可得：(10101)!的质因数2的个数为10000 - 1 + 00100 - 1 + 00001 - 1 = 10101 - 3(二进制表示中1的个数)

推及一般N!的质因数2的个数为N - (N二进制表示中1的个数)

                        .








65..toString(2).padStart(8, 0)转成二进制不足八位数自动左边补零




# 浮点数的表示

                      * 浮点数一般使用8字节即64bit存储，为双精度浮点数
                      * 也有用4字节即32bit存储的单精度浮点数
                      * [x | xxxxxxxx | xxxxxxxxxxxxxxxxxxxxxxx]
                      * 最左边一位表示符号，0表示正，1表示负
                      * 接下来的11bit表示指数
                      * 剩余的表示科学记数法中的小数部分，不含整数部分，因为整数部分总是1

                      > f.writeDoubleBE(NaN)
8
                        > f
                        < Buffer 7f f8 00 00 00 00 00 00 >
> f.writeDoubleBE(Infinity)
8
                        > f
                        < Buffer 7f f0 00 00 00 00 00 00 >
> f.writeDoubleBE(-Infinity)
8
                        > f
                        < Buffer ff f0 00 00 00 00 00 00 >
> f.writeDoubleBE(0)
8
                        > f
                        < Buffer 00 00 00 00 00 00 00 00 >
> f.writeDoubleBE(-0)
8
                        > f
                        < Buffer 80 00 00 00 00 00 00 00 >
>


* 为什么指数的范围是 - 1023到1024而非 - 1024到1023？
  * 指数部分并没有使用补码进行存储
                        * 正1024次方表示无穷大
                        * -1023次方表示无穷小(无限接近0)
                      * 为什么指数部分读出时要减1023，写入时要加1023？
  * 指数部分使用原码，范围是0到2047
                      * 表示 - 1023到1024
                      * 所以0表示 - 1023
                      * 所以读出时 / 解码时减1023，写入时 / 编码时加1023
                      * 为什么指数不用补码？
  * 为了能够从左往右扫描即可确定两个浮点数的大小
                        * 即除符号位以外只看指数部分即可以确定大小
                        * 即指数部分谁先出现1谁更大
                        * 如果指数部分完全相同，那么底数部分谁先出现1谁更大
                      * 为什么要如此在意浮点大小对比的效率？
  * 因为浮点数更多时候是对比大小而非对比相等
                        * 因为浮点数表示的不精确
                        * 很难保证数学上相等的两个计算路径在程序中的计算结果也是完全相同的
                        * 在程序中 a * b / c 的结果跟 a / c * b 有可能不相同的
                        * 所以在程序中很少判断两个浮点数的相等
                      * 而是判断它们在数轴上的距离，即求其差的绝对值看是否小于某个精度
                      * Math.abs(a - b) < Number.EPLSION
                      * 为什么不把底数的整数部分存储？
  * 因为底数的整数部分总是1
                        * 效果就是二进制状态下的有效位数是53位
                        * 正因为有效位数有53位，如果用这53位全部分表示整数
                      * 即2的53次方，可以保证在这个范围内的整数运算的精确
                      * 所以有一个常量Number.MAX_SAFE_INTEGER的值即为2的53减1
                      * 大于这个范围的数不是不能表示，只是不保证完全精确
                      * 大于这个范围无法表示浮点数，且整数也不是连续表示的
                      * 因为总的有效数字只有53位
                      * 所以如果整数部分使用的越多，小数部分就越小，反之亦然
                      * 而数值越大，整数部分需要的有效位数就越多，而小数部分的有效位数就越少
                      * 即数值越大，小数部分的精度就越低
                      * 而数值越小，整数部分需要的有效位数就越少，而小数部分的有效位数就越多
                      * 即数值越小，小数部分的精度就越高
                      * IEEE754
                      * 单精度浮点数 float   float32   f32
                      * 使用4字节表示，其指数部分8bit，底数23bit
                      * 双精度浮点数 double  float64   f64
                      * 使用8字节表示，指数部分11bit，底数52bit
最大数, Number.MAX_VALUE：
                        1.797e308
  并不表示这个数以内的数都是精确的
                        [0 | 11111111110 | 111111111111111111111111111111111111111111]
最小数,
                        -1.797e308
                        [1 | 11111111110 | 111111111111111111111111111111111111111111]
绝对值最小的数 Number.MIN_VALUE:
                        5e-324
                        [0 |00000000000 |000000000000000000000000000000000000000001]
最大精确整数：
                        将底数部分全部用来表示整数，不留空间表示小数部分
  9007199254740991   2 ** 53 - 1
                      [0 | xxxxxxxxxxx | 111111111111111111111111111111111111111111111111]
18000000000000000000这个数是什么？
                        是64bit浮点样可以表示的不同数字的数量
  它约等于2 ** 64






https://leetcode.cn/problems/majority-element/
                        https://leetcode.cn/problems/isomorphic-strings/
                        https://leetcode.cn/problems/first-unique-character-in-a-string/
                        https://leetcode.cn/problems/group-anagrams
                        https://leetcode.cn/problems/find-the-difference/
                        https://leetcode.cn/problems/ransom-note/

                        https://leetcode.cn/problems/binary-search/
                        https://leetcode.cn/problems/guess-number-higher-or-lower/
                        https://leetcode.cn/problems/self-dividing-numbers/


                        https://leetcode.com/problems/max-consecutive-ones/


for of 遍历数组

for in 遍历对象





var cache = {
                            1: 1,
                            2: 1,
                            3: 2,
                            4: 3,
                          }

                      function fibb(n) {
                        if (n in cache) {
                          return cache[n]
                        }
                        if (n < 2) {
                          return 1
                        } else {
                          return cache[n] = fibb(n - 1) + fibb(n - 2)
                        }
                      }
                      斐波那契数列



                      function maxSubArray(array) {
                        var max = 0
                        var start = 0
                        var end = 0

                        var sum = 0
                        for (var i = 0; i < array.length; i++) {
                          sum += array[i]
                          if (sum > max) {
                            max = sum
                            end = i
                          }
                          if (sum < 0) {
                            sum = 0
                            start = i + 1
                          }
                        }
                        return [max, start, end]

                      } arr.push(l)






                        .split('')转换为字符串
                          .sort()按字母顺序排序
                            .join('')分割





                      csv格式转换对象函数

                      function zhuanhuanCsv(csvString) {
                        var lines = csvString.trim().split('\n') // 将 CSV 字符串拆分为行数组
                        var result = [] // 存储拆分后的结果数组

                        lines.forEach(line => {
                          result.push(line.split(',')) // 将每一行按逗号拆分为字段，并添加到结果数组中
                        })

                        var [head, ...rest] = result // 将结果数组的第一行作为头部字段，剩余行作为数据

                        var objs = [] // 存储转换后的对象数组

                        for (var item of rest) {
                          var obj = {} // 创建空对象用于存储每一行的字段值

                          for (var i = 0; i < head.length; i++) {
                            obj[head[i]] = item[i] // 将每个字段与对应的值添加到对象中
                          }

                          objs.push(obj) // 将每一行的对象添加到结果数组中
                        }

                        return objs // 返回转换后的对象数组
                      }




                      function forEach(array, action) {
                        for (var i = 0; i < array.length; i++) {
                          if (action(array[i]) == false) {
                            break
                          }
                        }
                      }
                      支持break的forEach，通过让action返回false来停止迭代






                      将数组对象转换成对应格式

                      function stringify(value) {
                        if (typeof value === 'number') {
                          return String(value)
                        }
                        if (typeof value === 'string') {
                          return '"' + value + '"'
                        }
                        if (typeof value === 'boolean') {
                          return String(value)
                        }
                        if (value === null) {
                          return 'null'
                        }
                        if (Array.isArray(value)) {
                          var result = '['
                          for (var i = 0; i < value.length; i++) {
                            result += stringify(value[i]) + ','
                          }
                          return result.slice(0, -1) + ']'
                        }
                        if (typeof value === 'object') {
                          var result = '{'
                          for (var key in value) {
                            var val = value[key]
                            result += '"' + key + '":' + stringify(val) + ','
                          }
                          return result.slice(0, -1) + '}'
                        }
                      }






                      完全相等的JSON字符串

                      var isEqual = function (a, b) {
                        if (a === b) {
                          return true
                        }

                        if (a && b && typeof a === 'object' && typeof b === 'object') {
                          if (Array.isArray(a) === Array.isArray(b)) {
                            if (!Array.isArray(a)) {
                              var size = 0
                              for (var key in a) {
                                size++
                              }
                              for (var key in b) {
                                size--
                              }
                              if (size !== 0) {
                                return false
                              }
                            } else {
                              if (a.length !== b.length) {
                                return false
                              }
                            }


                            for (var key in a) {
                              if (!isEqual(a[key], b[key])) {
                                return false
                              }
                            }
                            return true
                          } else {
                            return false
                          }
                        }
                        return a === b
                      };


                      选择排序随机版
                      1.
                      function shuffle(array) {
                        var result = []
                        var l = array.length
                        for (i = 0; i < l; i++) {
                          var idx = Math.random() * array.length | 0
                          result.push(array[idx])
                          array.splice(idx, 1)
                        }
                        return result
                      }
                      2.

                      function shuffle(array) {
                        for (var i = array.length - 1; i > 0; i--) {
                          var idx = Math.random() * (i + 1) | 0
                          swap(array, i, idx)
                        }
                        return array
                      }



                      var a = 8, b = 2 * 0xB + f(5)
                      假想语法树:
                      {
                        type: '变量声明',
                          声明关键词: 'var', // 'let',
                            声明的变量们: [
                              {
                                type: '变量',
                                变量名: 'a',
                                初始化的值: 8
                              },
                              {
                                type: '变量',
                                变量名: 'b',
                                初始化的值: {
                                  type: 'BinaryExpression',
                                  运算: '+',
                                  left: {
                                    type: 'BinaryExpression',
                                    运算: '*',
                                    left: {
                                      type: '数值直接量',
                                      value: 2,
                                    },
                                    right: {
                                      type: '数值直接量',
                                      value: 11,
                                      source: '0xB',
                                    }
                                  },
                                  right: {
                                    type: '函数调用',
                                    函数: {
                                      type: '标识符',
                                      name: 'f',
                                    },
                                    参数列表: [{
                                      type: '数值直接量',
                                      value: 5,
                                      source: '5',
                                    }]
                                  }
                                }
                              }
                            ]
                      }


                      https://esprima.org/demo/parse.html#








                      <script>

/**
                        * 二叉树 binary  tree
                        * 为什么只研究二叉树？
                        * 因为把二叉树研究明白了，就能理解其它数量分支的树，本质都是一样的
                        * 为什么不研究一叉树？
                        *   一叉树就是链表
                        *
                        * 二叉树（多叉树）有哪些应用？
                        *   不管是现实中，还是编程中，有很多事物都是树结构
                        *      如书籍的目录，家谱，公司的组织架构
                        *         html，数学公式，js里面的对象与数组的嵌套
                        *          对象的嵌套实质上是树结构（没有环的情况下，就算有环，其中子结构也包含树结构）
                        *          程序里的表达式（表达式可以嵌套）
                        *          程序的语法，因为语句可以嵌套
                        *              事实上程序在运行之前会先被转换为一个树结构（称为语法树）
                        *                    https://esprima.org/demo/parse.html#
                        *          文件夹结构等等
                        *
                        *
                        *
                        * 二叉树的定义：
                        *   空  是一颗二叉树
                        *   一个根结点，其有一个左子树，是二叉树
                        *              其有一个右子树，是二叉树
                        *
                        *  满二叉树：除最后一层以外，每层的所有结点都有两个子结点
                        *  完全二叉树：当满二叉的最后一层的右边缺失一部分时，称完全二叉树
                        *
                        * 当一颗满二叉树有n层时，它有2**n-1个结点
                        * 当一颗满二叉树有x个结点时，它有  floor(log2(x)) + 1  层
                        * 如果为完全二叉树的结点从上到下从左右到从0开始进行编号时
                        *  编号为n的结点，其两个子结点的编号分别2n+1和2n+2
 *                其父结点的编号为 (n - 1) >> 1
                        *
                        * 任何一颗使用二叉链表形式表示的二叉树
                        *  当它有n个结点时，都正好有n+1个空置指针
                        *
                        *
                        * 二叉树的表示：
                        *   二叉链表的形式，即每个结点用一个对象表示
                        *    该对象有val，left，right属性，left指向左子树，right指向右子树
                        *   a = {
 * val: 1,
                        *     left: { },
                        *     right: { }
 *   }
                        *
                        *
                        *   数组表示法：将一颗完全二叉树表示到数组中，由于完全二叉的每个结点有着确定的编号，所以可以把编号做为下标保存在数组中
                        *     [1,2,3,4,null,5,6]
                        *        1
                        *      /   \
                        *     2     3
                        *    4     5 6
                        *
                        *
                        *
                        * 数组表示法，但是并不是把二叉树当完全二叉树，而是只把所有非空结点的子结点画出来
                        * 然后从上到正从左往右，把结点的值及空结点依次放入数组
                        *  很明显，这种方式，结点与其父子结点的位置没有确定的数学关系
                        *
                        *
                        */

                        // 将根结点在数组rootPosition位置的树转换为一颗二叉链表表示的树
                        function arrayToTree(array, rootPosition = 0) {
  if (array[rootPosition] == null) {
    return null
  }

                        var root = {
                          val: array[rootPosition],
                        left: null,
                        right: null,
  }

                        root.left = arrayToTree(array, rootPosition * 2 + 1)
                        root.right = arrayToTree(array, rootPosition * 2 + 2)

                        return root
}

                        // 将root表示的二叉树放入array中，根结点在idx位置，每个子结点在idx*2+1/2的位置
                        function treeToArray(root, idx = 0, array = []) {
  if (root == null) {
    return array
  }

                        array[idx] = root.val

                        treeToArray(root.left, idx * 2 + 1, array)
                        treeToArray(root.right, idx * 2 + 2, array)

  // for (var i = 0 ; i < array.length; i++) {
  //   if (!(i in array)) {
  //     array[i] = null
  //   }
  // }
  return array
}

// function tree2array(root) {
                          //   var array = treeToArray(root)

                          //   for (var i = 0 ; i < array.length; i++) {
                          //     if (!(i in array)) {
                          //       array[i] = null
                          //     }
                          //   }

                          //   return array
                          // }



                          // 将紧凑的数组转换为树
                          function arrayToTree2(array) {
                            if (array.length == 0 || array[0] == null) {
                              return null
                            }
                            var root = {
                              val: array[0],
                              left: null, right: null,
                            }

                            var nodes = [root]

                            for (var i = 1; i < array.length; i++) {
                              var currParent = nodes.shift()

                              var val = array[i]
                              if (val != null) { // val不是null，即要创建结点
                                var node = {
                                  val: val,
                                  left: null, right: null,
                                }
                                nodes.push(node)
                              } else {
                                node = null
                              }

                              currParent.left = node

                              i++

                              var val = array[i]
                              if (val != null) { // val不是null，即要创建结点
                                var node = {
                                  val: val,
                                  left: null, right: null,
                                }
                                nodes.push(node)
                              } else {
                                node = null
                              }

                              currParent.right = node
                            }
                            return root
                          }

function treeToArray2(root) {
  if (root == null) {
    return []
  }
                        var array = []

                        var nodes = [root]

  while (nodes.length > 0) {
    var node = nodes.shift()
                        if (node == null) {
                          array.push(node)
                        } else {
                          array.push(node.val)
      nodes.push(node.left)
                        nodes.push(node.right)
    }
  }

                        return array
}









                        <script>

/**
                          * 二叉树 binary  tree
                          * 为什么只研究二叉树？
                          * 因为把二叉树研究明白了，就能理解其它数量分支的树，本质都是一样的
                          * 为什么不研究一叉树？
                          *   一叉树就是链表
                          *
                          * 二叉树（多叉树）有哪些应用？
                          *   不管是现实中，还是编程中，有很多事物都是树结构
                          *      如书籍的目录，家谱，公司的组织架构
                          *         html，数学公式，js里面的对象与数组的嵌套
                          *          对象的嵌套实质上是树结构（没有环的情况下，就算有环，其中子结构也包含树结构）
                          *          程序里的表达式（表达式可以嵌套）
                          *          程序的语法，因为语句可以嵌套
                          *              事实上程序在运行之前会先被转换为一个树结构（称为语法树）
                          *                    https://esprima.org/demo/parse.html#
                          *          文件夹结构等等
                          *
                          *
                          *
                          * 二叉树的定义：
                          *   空  是一颗二叉树
                          *   一个根结点，其有一个左子树，是二叉树
                          *              其有一个右子树，是二叉树
                          *
                          *  满二叉树：除最后一层以外，每层的所有结点都有两个子结点
                          *  完全二叉树：当满二叉的最后一层的右边缺失一部分时，称完全二叉树
                          *
                          * 当一颗满二叉树有n层时，它有2**n-1个结点
                          * 当一颗满二叉树有x个结点时，它有  floor(log2(x)) + 1  层
                          * 如果为完全二叉树的结点从上到下从左右到从0开始进行编号时
                          *  编号为n的结点，其两个子结点的编号分别2n+1和2n+2
 *                其父结点的编号为 (n - 1) >> 1
                          *
                          * 任何一颗使用二叉链表形式表示的二叉树
                          *  当它有n个结点时，都正好有n+1个空置指针
                          *
                          *
                          * 二叉树的表示：
                          *   二叉链表的形式，即每个结点用一个对象表示
                          *    该对象有val，left，right属性，left指向左子树，right指向右子树
                          *   a = {
 * val: 1,
                          *     left: { },
                          *     right: { }
 *   }
                          *
                          *
                          *   数组表示法：将一颗完全二叉树表示到数组中，由于完全二叉的每个结点有着确定的编号，所以可以把编号做为下标保存在数组中
                          *     [1,2,3,4,null,5,6]
                          *        1
                          *      /   \
                          *     2     3
                          *    4     5 6
                          *
                          *
                          *
                          * 数组表示法，但是并不是把二叉树当完全二叉树，而是只把所有非空结点的子结点画出来
                          * 然后从上到正从左往右，把结点的值及空结点依次放入数组
                          *  很明显，这种方式，结点与其父子结点的位置没有确定的数学关系
                          *
                          *
                          */

                          // 将根结点在数组rootPosition位置的树转换为一颗二叉链表表示的树
                          function arrayToTree(array, rootPosition = 0) {
  if (array[rootPosition] == null) {
    return null
  }

                          var root = {
                            val: array[rootPosition],
                          left: null,
                          right: null,
  }

                          root.left = arrayToTree(array, rootPosition * 2 + 1)
                          root.right = arrayToTree(array, rootPosition * 2 + 2)

                          return root
}

                          // 将root表示的二叉树放入array中，根结点在idx位置，每个子结点在idx*2+1/2的位置
                          function treeToArray(root, idx = 0, array = []) {
  if (root == null) {
    return array
  }

                          array[idx] = root.val

                          treeToArray(root.left, idx * 2 + 1, array)
                          treeToArray(root.right, idx * 2 + 2, array)

  // for (var i = 0 ; i < array.length; i++) {
  //   if (!(i in array)) {
  //     array[i] = null
  //   }
  // }
  return array
}

// function tree2array(root) {
                            //   var array = treeToArray(root)

                            //   for (var i = 0 ; i < array.length; i++) {
                            //     if (!(i in array)) {
                            //       array[i] = null
                            //     }
                            //   }

                            //   return array
                            // }



                            // 将紧凑的数组转换为树
                            function arrayToTree2(array) {
                              if (array.length == 0 || array[0] == null) {
                                return null
                              }
                              var root = {
                                val: array[0],
                                left: null, right: null,
                              }

                              var nodes = [root]

                              for (var i = 1; i < array.length; i++) {
                                var currParent = nodes.shift()

                                var val = array[i]
                                if (val != null) { // val不是null，即要创建结点
                                  var node = {
                                    val: val,
                                    left: null, right: null,
                                  }
                                  nodes.push(node)
                                } else {
                                  node = null
                                }

                                currParent.left = node

                                i++

                                var val = array[i]
                                if (val != null) { // val不是null，即要创建结点
                                  var node = {
                                    val: val,
                                    left: null, right: null,
                                  }
                                  nodes.push(node)
                                } else {
                                  node = null
                                }

                                currParent.right = node
                              }
                              return root
                            }

function treeToArray2(root) {
  if (root == null) {
    return []
  }
                          var array = []

                          var nodes = [root]

  while (nodes.length > 0) {
    var node = nodes.shift()
                          if (node == null) {
                            array.push(node)
                          } else {
                            array.push(node.val)
      nodes.push(node.left)
                          nodes.push(node.right)
    }
  }

                          return array
}




                          /** 二叉树的遍历(二叉链表形式)
                           *
                           * 先序遍历
                           *  先遍历根结点，再遍历左子树，再遍历右子树
                           *  对于子树的遍历同样是（根左右）的顺序递归进行
                           * 中序遍历 左中右
                           * 后序遍历 左右中
                           *
                           * 把遍历想成是读一本书有两章，每章有两节，每节有两小节，每小节有两个段。。
                           * 把每章、节、小节、段都称为一部分
                           * 先序遍历
                           *    “读过”每部分的顺序
                           * 中序遍历
                           *    对每部分按“读了一半”顺序排序，得到的就是中序遍历
                           * 后序遍历
                           *    “读完”每部分的顺序
                           *
                           *
                           */

                          var tree = arrayToTree2([1,2,3,4,5,,6,,7,8,9,,,,10,,11])

                          先序遍历 根左右
                          function preorderTraverse(root, action = console.log) {
  if (root) {
                            action(root.val)
    preorderTraverse(root.left, action)
                          preorderTraverse(root.right, action)
  }
}
                          document .write( array[i])

                          中序遍历 左中右
                          function inorderTraverse(root) {
  if (root) {
                            inorderTraverse(root.left)
    console.log(root.val)
                          inorderTraverse(root.right)
  }
}


                          后序遍历 左右中
                          function postorderTraverse(root) {
  if (root) {
                            postorderTraverse(root.left)
    postorderTraverse(root.right)
                          console.log(root.val)
  }
}

                          返回结果数组
                          function preorderTraverse(root) {
  if (root) {
    return [root.val, ...preorderTraverse(root.left), ...preorderTraverse(root.right)]
  }
                          return []
}

                    </script>


                    // 按层遍历
                    function levelOrderTraverse(root) {
                    if (!root) {
                    return []
                    }
                    var currRow = [root]
                    var nextRow = []
                    var result = []

                    while (currRow.length) {
                    var currRowVals = []
                    for (var i = 0; i < currRow.length; i++) { var node=currRow[i] currRowVals.push(node.val) if
                      (node.left) { nextRow.push(node.left) } if (node.right) { nextRow.push(node.right) } }
                      result.push(currRowVals) currRow=nextRow nextRow=[] } return result } // 拼出一个html用于显示二叉树 function
                      showTree(root) { if (root) { var html='<div style="display:flex;flex-wrap:wrap;">' html
                      +='<header style="width:100%;text-align:center;">' + root.val + '</header>' html
                      +='<aside style="flex:50% 0 0">' + showTree(root.left) + '</aside>' html
                      +='<aside style="flex:50% 0 0">' + showTree(root.right) + '</aside>' html +='</div>' return html }
                      return '' } /* node={ val: xxxx, left: null, right: null, } leetcode创建二叉树结点的写法： node=new
                      TreeNode(1) BST Binary Search Tree 二叉搜索树 排序二叉树 任意结点的左子树上的结点的值都比该结点小 任意结点右子树上的结点的值都大于等于该结点
                      排序二叉树的中序遍历序列是有序的 */ function insertIntoBST(root, val) { if (root==null) { return { val: val, left:
                      null, right: null, } } if (val < root.val) { root.left=insertIntoBST(root.left, val) } else {
                      root.right=insertIntoBST(root.right, val) } return root } function insertIntoBST2(root, val) { if
                      (root==null) { return { val: val, left: null, right: null, } } var p=root while(true) { if (val <
                      p.val) { if (p.left) { p=p.left } else { p.left={ val: val, left: null, right: null, } break } }
                      else { if (p.right) { p=p.right } else { p.right={ val: val, left: null, right: null, } break } }
                      } return root } /** * * 通过构建bst来进行排序 * 时间复杂度：n*log(n) * 空间复杂度：n * * 最差情况下的时间复杂度：n * n *
                      因为最差情况下，当输入数组本就是有序的时，它将退化为一个链表 * 每一次添加元素，相当于把它添加到链表末尾 * */ function BSTSort(ary) { var root=null
                      for (var x of ary) { root=insertIntoBST2(root, x) } var result=[] inorderTraverse(root, val=> {
                      result.push(val)
                      })

                      return result
                      }




                      </script>





                      封装函数

                      document .write把东西write到页面里，最好只有一次



                      API应用程序编程接口
                      API Application Programming Interface

                      GUI图形用户界面
                      GUI Graphic User Interface

                      CLI命令行界面
                      CLI Command Line Interface



                      this是一个隐藏参数
                      它的值由调用形式/方式决定
                      而不由这个函数的声明位置，或其调用位置决定
                      函数内部使用的那些函数自身没有声明的变量，由函数的声明位置决定，此为词法作用域
                      函数能够接收的参数，由调用位置决定，在哪里调用，可以传哪个作用域能够使用的变量
                      this的值不取决于调用位置，也不取决于声明位置，而取决于其调用方式
                      obj.foo() // this in foo is obj
                      foo.call(xxx) // this in foo is xxx, this in call is foo


                      this的值跟调用栈，闭包，都没有关系


                      Object.create(o) // 创建以o为原型的新的空对象
                      Object.getPrototypeOf(obj) // 获取obj的原型
                      以前等价于 obj.__proto__
                      Object.setPrototypeOf(obj, target) // 设置obj对象的原型为target
                      以前造价于 obj.__proto__ = target
                      现在当obj最终以Object.prototype为原型时，也是等价的
                      但当obj没有原型或并不最终以Object.prototype为原型时，则不等价

                      几乎每个对象都有原型，原型也是一个普通的对象，当在一个对象上查找某个属性但找不到时，会到其原型对象上找，依次类推，一直找到最终原型
                      最终原型是Object.prototype，几乎所有对象最终都以它为原型，所以它上面的属性和方法可以在几乎所有对象上访问到
                      但并不是所有的对象都直接以它为原型，往往是以其它对象为原型，最终才以它为原型
                      这就形成了原型链(prototype chain)
                      所有的数值都以Number.prototype为原型
                      所有的字符串都以String.prototype为原型
                      所有的函数都以Function.prototype为原型
                      所有的数组都以Array.prototype为原型
                      实际上Number String Function Array都是构造函数
                      每种类型都有自己的构造函数
                      每个构造函数都有一个prototype属性，做为该类型的值的原型



                      Object.keys(obj)返回obj的自有可枚举属性，顺序与forin一致







                      箭头函数
                      箭头函数总是表达式，没有声明式写法
                      内部没有this，使用时相当于词法作用域，在外层作用域找
                      内部没有arguments，使用时相当于词法作用域，在外层作用域找
                      箭头函数不能被new，所以箭头函数不能做为构造函数
                      箭头函数没有prototype属性



                      function isArray(val) {
                      return Object.prototype.toString.call(val) === '[object Array]'
                      }


                      Object.prototype

                      Object.defineProperty(obj2, 'eee', { // 属性描述符 property descryptor

                      value: 888,
                      是否可枚举: true/false,
                      是否可修改: true/ false,
                      是否可以重新定义: true/false // 即是否能重新通过defineProperty函数为这个对象定义这个属性以改变“修改性”和“枚举性”

                      })


                      {
                      "value": 888,
                      "writable": false,

                      "enumerable": false,
                      "configurable": false
                      }




                      prototype属性不是每个对象都有，而每个function都有，但只有做为构造函数的function的prototype才有意义
                      构造函数的prototype是用来做为其创建的实例对象的原型的
                      构造函数的prototype属性不是自己的原型，而是其实例的原型
                      构造函数自己的原型为 F.__proto__ 或 Object.getPrototypeOf(F)
                      一般对象没有prototype属性，不像“每个对象都有原型”
                      只有构造函数需要prototype，但所有函数都有prototype



                      一个构造函数代表一个新的数据类型
                      这个数据类型能进行的操作通过其上的方法来表达
                      这个数据类型的信息由其上的属性来表达






                      this
                      this的值由调用方式决定：
                      obj.foo(1,2) // 当对象的方法调用,this为obj
                      foo(1,2) // 当函数调用（即从一个变量而非对象的属性上读到一个函数），this为全局作用域对象，在浏览器里就是window对象
                      // 在严格模式下，当函数调用时，this为undefined
                      foo.call(obj,1,2) // 通过call，apply调用，直接设定this为某个值，即它们的第一个参数
                      new foo() // 当构造函数调用，this为一个新的空对象，且其原型为foo.prototype
                      箭头函数，没有this，在箭头函数内使用this时，找其外面的this的指向，类似于在if语句块内使用this
                      函数不“属于”一个对象，将对象中的属性读出到一个变量中，再通过变量调用，this将不再是之前那个对象
                      而另一个对象的属性指向函数，通过第二个对象来调用这个函数，this将会是第二个对象

                      原型
                      除了null与undefined，js里的每个对象都有原型
                      原型的作用是属性查找的后备来源，即在对象上读取某个属性时，如果对象自身没有，则到其原型上找
                      原型也只是一个普通的对象，所以它也可能有其它对象做为自己的原型
                      以此形成原型链
                      在原型链的最顶端，是Object.prototype这个对象，即所有的对象最终都以它为原型
                      所以它上面的方法可以在所有对象上存在
                      可通过obj.__proto__获取到一个对象的原型
                      或通过Object.getPrototypeOf(obj)获取
                      也可以通过Object.setPrototypeOf(obj, p)设定obj对象的原型
                      一般是会用共享同个原型的一系列来表达一个特定类型的事物
                      比如所有表示兔子的对象共用一个原型
                      所有表示链表的对象，共用一个原型
                      但由于用以上方式创建共享原型的对象比较麻烦，所以有了构造函数

                      构造函数
                      可以方便的通过构造函数创建一系共享原型的对象
                      通过构造函数创建的对象都以构造函数的prototype属性为原型
                      注意这个prototype属性是构造函数特有的，不像“原型”是每个对象都有
                      构造函数运行时，其内的this为一个新的空对象，我们可以为其添加表示特定事物的属性
                      如果构造函数不主动返回一个真对象（非原型类型）则其this会被返回
                      一般来说我们想用这个this表达什么事物，构造函数将起这个事物的名称，且首字母大写以表达它是个构造函数
                      构造函数（实际上所有function声明的函数）自动有一个prototype属性，只不过不做为构造函数的函数这个属性就没什么用了
                      这个属性一开始指向一个几乎是空的对象，其有一个constructor属性，指向该构造函数自身
                      所以所有构造函数构造出来的实例，都可以通过constructor属性访问到其构造函数

                      对象属性操作
                      对象的属性有是否可以枚举的行为，即有些属性不会自动出现在for/in循环里
                      只要一个属性是可枚举的，即使它出现其原型链中，也会在对象被遍历时出现
                      可以通过obj.hasOwnProperty(key)来判断对象是否有一个自有属性key
                      如果创建不可枚举属性？
                      Object.defineProperty(obj, key, {
                      value: 88,
                      enumerable: true/false,
                      writable: true/false,
                      configurable: true/false,
                      })
                      通过obj.foo = xxx的方式添加的属性这几个维度都是真
                      而通过defineProperty定义的属性这几个维度默认都为假
                      可以通过Object.create(null)创建无原型对象




                      class B {}
                      class A extends B {

                      }




                      <script>

                          // TypeScript

                          var f: string | number = 2;

                          f = 'owief'

                          var g: number[] = [1, 2, 3, 3, 3, 3, 3]
                          var h: string[] = ['wfeof', 'wief']
                          var i: (number | string)[] = [2, '2']

                          type Coord = {
                            a: string,
                          b: string,
}

                          type Point = {
                            x: number,
                          y: number,
                          z: Coord
}

                          interface Point2 {
                            foo(a: number): string;
                          bar: boolean;
}

                          var obj3: Point2 = {
                            foo(b) {
    return 'oweifj'
  },
                          bar: false,
}

                          var j: Point = {x: 2, y: 8, z: {a:'weofi', b:'owief'}}
                          var k: Point = {x: 2, y: 8 }
                          var k: Point = {x: 2, y: 8 }

                          var x: undefined = undefined;
                          var d: null = null;
                          var e: bigint = 8234n;

                          var a: number = 2;
                          var b: string = 'wef';

                          a.toString(2)

                          function foo(a: number, b: number): string {
  return String(a) + String(b)
}

                          var c: number = Number(foo(1, 2))

                          class A {
                            constructor() {

                          }

                          foo(x: string, y: boolean): number {
    return 2
  }
}


                          var xxx: A[] = []

                          xxx.push(  2  )




                      </script>


                      静态/动态类型：变量是否有固定的类型
                      静态: c, c++, java, typescript, rust
                      动态: js, python


                      强/弱类型：语言是否支持自动类型转换
                      强类型：python, java
                      弱类型：c, js




                      变态面试题
                      var a = {
                      i: 2,
                      toString() {
                      return this.i++
                      }
                      }
                      if (a == 2 && a == 3) {
                      console.log(1)

                      }




                      var i = 2
                      Object.defineProperty(window, 'a', {
                      get: function () {
                      return i++
                      }
                      })
                      a是对象的情况下添加循环
                      如何成立以下代码
                      if (a == 2 && a == 3) {
                      console.log(1)
                      }


                      如何获取obj本身

                      function closeObject(obj) {
                      return function(key) {
                      return obj[key]
                      }
                      }
                      在对象的原型上设置
                      Object.defineProperty(Object.prototype, 'self', {get: function(){return this}})

                      x = closeObject(obj)

                      x('self')






                      ** 正则表达式
                      **
                      ** exec(): 用于在字符串中执行查找，并返回结果数组。如果未找到匹配，则返回null。
                      **
                      ** test(): 用于在字符串中测试匹配。如果字符串中包含匹配的文本，则返回true，否则返回false。
                      **
                      ** match(): 用于在字符串中查找一个或多个匹配，返回匹配到的结果数组或null。
                      **
                      ** replace(): 用于在字符串中用一些字符替换匹配到的文本或执行一个数来实际替换。
                      **
                      ** search(): 用于在字符串中查找匹配的文本，并返回匹配到的文本首字符在字符串中的位置。
                      **
                      ** split(): 用于将一个字符拆分成数组，可以使用正则表达式作为分隔符。
                      **

                      ** 正则表示达式中常用的内部设置写法如下：
                      **
                      ** \d:配对数字字符符，等同于[0-9]。
                      **
                      ** \D:匹配非数字字符符，等同于[^0-9]。
                      **
                      ** \w:配对单字符，包括数字和字母，等同于 [0-9a-zA-Z_]。
                      **
                      ** \W:配对非单字符，等同于 [^0-9a-zA-Z_]。
                      **
                      ** \s:匹配空格字符，包含空格、制表符、交换页符等。
                      **
                      ** \S:配对非空格字符符。
                      **
                      ** \b:匹配单词边界，例如单词和空格之间的边界。\B 匹配非单词边界的位置。
                      **
                      ** .：配对去除换行符以外的任意字符符。
                      **
                      ** 除此以外，还有一些内部设置写法需要配准限定符使用，例如：
                      **
                      ** *：匹配前面的表现形式零次或多次。
                      **
                      ** +：搭配前面的表现形式一次或多次。
                      **
                      ** ?：匹配前面的表达式零次或一次。

                      **
                      ** {n}：精确匹配前面的表达式 n 次。
                      **
                      ** {n,}：匹配前面的表达式至少 n 次。
                      **
                      ** {n,m}：匹配前面的表达式至少n次，但不超过m次。
                      **

                      ** lastIndex 是正则表达式对象上的一个属性，表示搜索下一个匹配值的起始索引。lastIndex 属性仅在使用 g 全局标志时才有意义，否则每次调用正则表达式的 exec() 或
                      test() 方法都会将 lastIndex 重置为 0。
                      **
                      ** 当使用 g 全局标志进行正则匹配时，每次匹配都会从 lastIndex 索引开始搜索，直到字符串结尾，一旦匹配成功，lastIndex 的值就会被更新为下一次匹配的起始位置。
                      **
                      ** 例如：
                      **
                      **
                      ** const re = /a/g;
                      ** const str = 'abcdabcd';
                      **
                      ** console.log(re.lastIndex); // 0
                      **
                      ** re.test(str); // true
                      ** console.log(re.lastIndex); // 1
                      **
                      ** re.test(str); // true
                      ** console.log(re.lastIndex); // 5
                      **
                      ** re.test(str); // false
                      ** console.log(re.lastIndex); // 0
                      **
                      **
                      ** 在上面的例子中，定义了一个正则表达式 /a/g，然后进行了几次匹配，每次匹配时 lastIndex 的值都随着匹配起始位置的变化而不同。
                      **
                      ** 如果正则表达式中不使用 g 全局标志，则每次匹配完成后 lastIndex 都会被重置为 0。因此，在匹配之前不需要显式地将 lastIndex 属性设置为 0。


                      JavaScript中的正则表达式是由正则表达式字面量（用斜杠`/`包裹的字符串）或RegExp构造函数生成的对象。正则表达式用于在字符串中匹配模式，常用于搜索、替换和验证字符串。

                      以下是一些JavaScript中正则表达式的语法及用法：

                      1. 正则表达式字面量

                      正则表达式字面量的语法是`/pattern/`，其中pattern为正则表达式的字符串。

                      ```javascript
                      const pattern = /foo/;
                      const str1 = 'food';
                      const str2 = 'seafood';
                      const result1 = pattern.test(str1); // true
                      const result2 = pattern.test(str2); // true
                      ```

                      在上述示例中，正则表达式字面量创建了一个匹配"foo"的正则表达式对象，并且使用`test()`方法测试了两个字符串。

                      2. RegExp构造函数

                      RegExp构造函数可以生成正则表达式对象，其语法为`new RegExp(pattern[, flags])`，其中pattern为正则表达式的字符串，flags为可选的标志字符串。

                      ```javascript
                      const pattern = "foo";
                      const reg1 = new RegExp(pattern);
                      const reg2 = /foo/;
                      const str1 = 'food';
                      const str2 = 'seafood';
                      const result1 = reg1.test(str1); // true
                      const result2 = reg2.test(str2); // true
                      ```

                      在上述示例中，RegExp构造函数和正则表达式字面量都创建了一个匹配"foo"的正则表达式对象，并且使用`test()`方法测试了两个字符串。

                      3. 标志

                      RegExp对象的标志用于修改正则表达式的行为，可用于全局匹配、忽略大小写等操作。常用的标志有：

                      - `g`：全局匹配，匹配所有符合条件的字符串而非第一个。
                      - `i`：忽略大小写匹配。
                      - `m`：多行匹配，即在查找文本中包含换行符的情况下也能匹配到。

                      ```javascript
                      const pattern1 = /foo/g; // 全局匹配
                      const pattern2 = /foo/i; // 忽略大小写
                      const pattern3 = /^foo/m; // 多行匹配
                      const str = 'food(food)FOOD';
                      const result1 = str.match(pattern1); // ['foo', 'foo']
                      const result2 = str.match(pattern2); // ['foo', 'foo', 'FOO']
                      const result3 = str.match(pattern3); // ['foo']
                      ```

                      在上述示例中，`match()`方法用于查询符合正则表达式的字符串，通过不同的标志可以得到不同的匹配结果。

                      4. 量词

                      正则表达式中的量词用于控制匹配的次数，可以指定一个或一组字符必须出现的次数，或指定一个字符可出现的次数范围。

                      常用的量词有：

                      - `*`：匹配0个或多个。
                      - `+`：匹配一个或多个。
                      - `?`：匹配0个或一个。
                      - `{n,m}`：匹配n到m个。
                      - `{n,}`：匹配n个或多个。

                      ```javascript
                      const pattern1 = /fo*/;
                      const pattern2 = /fo+/;
                      const pattern3 = /fo?/;
                      const pattern4 = /fo{1,3}/;
                      const str = 'foooooood';
                      const result1 = pattern1.test(str); // true
                      const result2 = pattern2.test(str); // true
                      const result3 = pattern3.test(str); // true
                      const result4 = pattern4.test(str); // true
                      ```

                      在上述示例中，量词用于指定"o"出现的次数。`test()`方法用于测试字符串是否符合正则表达式。

                      5. 正则表达式组

                      正则表达式中的组用于划分匹配的范围，包括捕获组和非捕获组。

                      捕获组由圆括号包围，可以将匹配的结果保存在一个数组中。

                      非捕获组也由圆括号包围，但在组的左侧添加一个问号和一个冒号，不会把匹配保存到数组中。

                      ```javascript
                      const pattern1 = /f(o+)/;
                      const pattern2 = /f(?:o+)/;
                      const str = 'foooooood';
                      const result1 = str.match(pattern1); // ['foooooo', 'oooooo']
                      const result2 = str.match(pattern2); // ['foooooo']
                      ```

                      在上述示例中，捕获组`/(o+)/`匹配"o"出现一个或多个的重复，并将匹配结果保存在数组中（结果包括整个匹配结果和捕获组结果）。非捕获组`/(?:o+)/`在匹配时忽略括号中的子表达式，并将整个匹配结果保存到数组中。

                      6. 特殊字符

                      正则表达式中的一些字符有特殊的含义，需要通过转义字符（反斜杠`\`）来匹配本身。

                      常用的特殊字符有：

                      - `.`：匹配除换行符外的任意一个字符。
                      - `\d`：匹配数字，等价于`[0-9]`。
                      - `\w`：匹配字母、数字和下划线，等价于`[a-zA-Z0-9_]`。
                      - `\s`：匹配任意空白字符，包括空格、制表符、换行符等。
                      - `^`：匹配字符串的开始。
                      - `$`：匹配字符串的结束。

                      ```javascript
                      const pattern1 = /foo\d/;
                      const pattern2 = /\w+/;
                      const pattern3 = /^\w+@\w+\.\w+$/;
                      const str1 = 'foo1 bar2';
                      const str2 = 'hello, world!';
                      const str3 = 'user@example.com';
                      const result1 = pattern1.test(str1); // true
                      const result2 = str2.match(pattern2); // ['hello', 'world']
                      const result3 = pattern3.test(str3); // true
                      ```

                      在上述示例中，特殊字符用于匹配数字、单词、电子邮件地址等。`match()`方法用于返回一个数组，包含所有符合正则表达式的部分。










                      <script>
                          标签模版字符串
                          function raw(strs, ...vals) { // String.raw
                          var result = strs.raw[0]
                          for (i = 0; i < vals.length; i++) {
                            result += vals[i] + strs[i + 1]
                          }
                          return result
                       }

                      </script>


                      tagged template string

                      一个函数表达式后紧跟一个用``引住的模板字符串,模板字符串中可以正常使用插值运算符
                      foo`aa${2 + 3}bb${ Math.sqrt(2) }cc`

                      该表达式是会以特定的参数调用foo函数
                      foo的第一个参数是一个数组，内容为被插值符号拆分开的各字符串的部分
                      同时该数组有一个raw属性指向中另一个数组，其中是所有字符串各部分未转义的内容
                      后续的参数为每个插值符中表达式的求值结果

                      foo函数的返回值将成为整个表达式的值
                      foo`abf${2}owief${3+2}jowi \ l'arguments
                      Arguments(3)[Array(3)，2， 5, callee: f， Symbol (Symbol.iterator): f]0: Array ( 3)
                      :"abf"1:"owief"2: "jowi\ l"length: 3
                      raw: (3)[ 'abf' , 'owief' , 'jowi\ \ll '][ [ Prototype]]: Array(e)
                      1:2
                      2: 5
                      callee: f foo()










                      Code Point 码点
                      即unicode标准中为某个不可拆分的符号指定的一个编号
                      Code Unit 编码单元
                      是具体编码方式中,最小的单位
                      在utf8中是一个字节
                      在utf16中是两个字节
                      utf8编码
                      1字节 0xxxxxxx
                      2字节 110xxxxx 10xxxxxx
                      3字节 1110xxxx 10xxxxxx 10xxxxxx
                      4字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                      utf16编码
                      1编码单元: xxxxxxxxxxxxxxxx
                      2编码单元: 110110xxxxxxxxxx 110111xxxxxxxxxx
                      目前utf16最多占两个编码单元(4字节)
                      unicode的0xFFFF以内的字符不存在以11011开头的字,所以utf16 2编码单元的字不会与1编码单元的字产生冲突或歧义
                      'foo'.codePointAt(0) 从这个编码单元开始,解析一个码点出来
                      'foo'.length 返回编码单元的数量
                      grapheme 字位
                      是显示在一个字的区域内的一个字符
                      多数时候就是一个码点
                      但也有可能通过0x200D这个连接符连接多个符号并显示一个字位内
                      如 实际是由这四个独立码点通过0x200d这个码点连接而成的
                      但它是当做一个字的


                      RegExp 101 hover高亮
                      https://jsbin.com/gaqexibeca/2/edit?html,css,output






                      0
                      **正向零宽断言(Positive Lookahead):表示在当前位置后面必须出现某个内容。它使用语法 (?=...) 表示，其中 ... 是要匹配的内容。
                      例如，正则表达式 foo(?=bar) 匹配前面是 "foo" 且后面是 "bar" 的字符串，但不匹配实际的 "bar" 部分。

                      **负向零宽断言(Negative Lookahead):表示在当前位置后面不能出现某个内容。它使用语法 (?!...) 表示。
                      例如，正则表达式 foo(?!bar) 匹配前面是 "foo" 但后面不是 "bar" 的字符串。

                      **正向零宽否定断言(Positive Lookbehind):表示在当前位置前面必须出现某个内容。它使用语法 (?<=...) 表示。 例如，正则表达式 (?<=foo)bar
                        匹配前面是 "foo" 的 "bar" 字符串。 **负向零宽否定断言(Negative Lookbehind):表示在当前位置前面不能出现某个内容。它使用语法 (?<!...) 表示。
                        例如，正则表达式 (?<!foo)bar 匹配前面不是 "foo" 的 "bar" 字符串。 返回数组所有排列 <script>

                        返回数组所有排列

                        function permute(nums) {
                        const result = []; // 存储所有排列方式的结果数组

                        // 递归函数，生成数组的排列
                        function generatePermutations(current, remaining) {
                        if (remaining.length === 0) {
                        // 如果没有剩余元素，将当前排列添加到结果中
                        result.push(current.slice());
                        return;
                        }

                        for (let i = 0; i < remaining.length; i++) { const newCurrent=current.concat(remaining[i]); //
                          将当前元素添加到当前排列 const newRemaining=remaining .slice(0, i) .concat(remaining.slice(i + 1)); //
                          从剩余元素中移除当前元素 generatePermutations(newCurrent, newRemaining); // 递归生成排列 } }
                          generatePermutations([], nums); // 调用递归函数，初始排列为空数组 return result; // 返回所有排列方式的结果数组 } // 测试
                          const nums=[1, 2, 3]; const permutations=permute(nums); console.log(permutations); </script>



                          //如果没有el.textContent
                          function getTextContent(node) {
                          if (node.nodeType == document.TEXT_NODE) {
                          return node.nodeValue
                          } else if (node.nodeType == document.ELEMENT_NODE) {
                          var result = ''
                          for (var child of node.childNodes) {
                          result += getTextContent(child)
                          }
                          return result
                          } else {
                          return ''
                          }
                          }



                          // 先序遍历node及其后代元素
                          function traverse(node, action) {
                          action(node)
                          for (var child of node.childNodes) {
                          traverse(child, action)
                          }
                          }


                          function getTextContent2(node) {
                          var result = ''
                          traverse(node, currNode => {
                          if (currNode.nodeType == document.TEXT_NODE) {
                          result += currNode.nodeValue
                          }
                          })
                          return result
                          }


                          // 先序遍历node及其后代元素
                          function traverse(node, action) {
                          action(node)
                          // 不用判断结点类型,因为文本结点和注释结点也有childNodes只不过是空的
                          for (var child of node.childNodes) {
                          traverse(child, action)
                          }
                          }


                          function getTextContent2(node) {
                          var result = ''
                          traverse(node, currNode => {
                          if (currNode.nodeType == document.TEXT_NODE) {
                          result += currNode.nodeValue
                          }
                          })
                          return result
                          }



                          function getOuterHTML(node) {
                          if (node.nodeType == document.TEXT_NODE) {
                          return node.nodeValue
                          } else if (node.nodeType == document.COMMENT_NODE) {
                          return '<\!--' + node.nodeValue + '-\->' } else if (node.nodeType==document.ELEMENT_NODE) {
                            var tagName=node.nodeName.toLowerCase() var attrNames=node.getAttributeNames() var
                            属性集合=attrNames.map(name=> {
                            var val = node.getAttribute(name)
                            return `${name}="${val}"`
                            }).join(' ')

                            return `<${tagName}${属性集合 ? ' ' : '' }${属性集合}>
                              ${Array.from(node.childNodes).map(getOuterHTML).join('')}</${tagName}>`
                              }
                              }


                              </script>

                              function getElementsByTagName(node, tagName) {
                              var elements = [];
                              var childNodes = node.childNodes;

                              for (var i = 0; i < childNodes.length; i++) { var child=childNodes[i]; if
                                (child.nodeType===1 && child.tagName.toLowerCase()===tagName.toLowerCase()) {
                                elements.push(child); } elements=elements.concat(getElementsByTagName(child, tagName));
                                } return elements; } var container=document.getElementById('container'); // 获取父节点 var
                                elements=getElementsByTagName(container, 'div' ); // 获取所有子节点中的div元素 for (var i=0; i <
                                elements.length; i++) { console.log(elements[i].textContent); // 打印div元素的文本内容 }
                                el.nodeType 元素类型 el.nodeValue 元素的内容,对于文本及注释结点,就是其文字内容 el.nodeName
                                标签名称,对于文本结点来说是'#text',对于注释结点是'#comment' el.className class属性的值,包含所有类名
                                el.classList.add/remove/toggle/contains/replace
                                专门用来操作元素类名的一个对象,可以方便的对类名进行增/删/切换/存在性查找/替换 el.id 获取元素的id el.htmlFor 获取label元素的for属性
                                el.innerHTML 获取或设置元素的内部内容的html源代码 el.outerHTML 获取或设置元素整体的html源代码 el.textContent
                                获取或设置元素内部的所有纯文字内容 el.innerText 获取或设置元素内部的所有纯文字内容,但这个属性受css样式的影响,即css显示成什么样,它获取到什么样
                                el.outerText 其实是完全等价于innerText el.dataset.xxxx 操作data-开头的属性 el.first/lastChild
                                el.previous/next[Element]Sibilings el.get/set/has/removeAttribute() el.childNodes 所有子结点
                                el.children 所有元素子结点 el.remove/appendChild(node) el.append/prepend(...nodes)
                                el.insertBefore/replaceChild(newNode, oldNode) document.getElementById()
                                el.getElementsByTagName() el.getElementsByClassName() el.style.styleName='xxxxx' //
                                读取或改变元素的内联样式 el.style.color='red' el.style.fontSize='25px' el.style.lineHeight=2
                                在JS里可以用的css样式 在标签后面接style 类似于td.style.color设置字体颜色 以下是一些常见的可以使用 `style` 属性进行设置的 CSS
                                样式属性示例： - `color`: 设置文本颜色。 - `backgroundColor`: 设置背景颜色。 - `fontSize`: 设置字体大小。 -
                                `fontFamily`: 设置字体族。 - `fontWeight`: 设置字体粗细。 - `textAlign`: 设置文本对齐方式。 - `width`: 设置元素宽度。
                                - `height`: 设置元素高度。 - `margin`: 设置元素外边距。 - `padding`: 设置元素内边距。 - `border`: 设置元素边框。 -
                                `display`: 设置元素的显示方式。 - `position`: 设置元素的定位方式。 - `opacity`: 设置元素的透明度。 - `transition`:
                                设置元素的过渡效果。 - `boxShadow`: 设置元素的阴影效果。 - `textDecoration`: 设置文本修饰效果（如下划线、删除线等）。 -
                                `textTransform`: 设置文本的大小写转换方式。 - 'borderRadius' : 设置元素的边框圆角。 - 'textDecoration' :
                                设置文本的修饰效果（如下划线、删除线等）。 - 'textTransform' : 设置文本的大小写转换方式。 - 'textShadow' : 设置文本的阴影效果。
                                - 'boxShadow' : 设置元素的阴影效果。 - 'opacity' : 设置元素的透明度。 - 'backgroundImage' : 设置元素的背景图像。
                                - 'backgroundPosition' : 设置元素背景图像的位置。 - 'backgroundRepeat' : 设置元素背景图像的重复方式。
                                - 'backgroundSize' : 设置元素背景图像的大小。 - 'boxSizing' : 设置盒模型的计算方式（content-box、border-box）。
                                - 'overflow' : 设置元素的溢出内容的处理方式。 - 'cursor' : 设置鼠标指针的样式。 - 'listStyleType' : 设置列表项的标记样式。
                                - 'whiteSpace' : 设置元素内空白字符的处理方式。 - 'lineHeight' : 设置行高。 - 'verticalAlign' : 设置元素的垂直对齐方式。
                                - 'textOverflow' : 设置文本溢出时的处理方式。 - 'transition' : 设置元素过渡效果。 - 'zIndex' : 设置元素的堆叠顺序。
                                - 'float' : 设置元素的浮动方式。 - 'clear' : 设置元素的浮动清除方式。 这只是一小部分可用的样式属性示例，实际上有很多可以使用的样式属性，
                                用于控制元素的外观和布局。根据需要，你可以使用适当的样式属性来设置元素的样式。 记得在设置属性值时使用适当的单位和值。 请注意，某些样式属性的值可能需要特定的格式，
                                例如颜色属性需要使用正确的颜色值（如 color: 'red' 或 color: '#FF0000' ）。
                                另外，一些属性可能仅在特定的元素或条件下生效。详细了解每个样式属性的用法和限制，可以参考相关的 CSS 文档和规范。
                                这只是一小部分可用的样式属性示例，实际上有很多可以使用的样式属性， 用于控制元素的外观和布局。你可以根据需要使用任何 CSS 属性来设置元素的样式，以实现所需的视觉效果。
                                需要注意的是，在使用 `style` 属性设置样式时， 属性名使用驼峰式命名法，如 `backgroundColor`、`fontSize` 等。
                                同时，在设置属性值时，需要使用适当的单位，如像素（px）、百分比（%）、ems（em）等，具体根据属性的要求进行设置。 计算布局: 改变了dom并重新读取布局属性时 绘制页面:
                                js代码运行完之后 绘制页面是需要计算布局的 js运算过程中,改了dom的话,浏览器有可能重新计算布局(当用js读取元素的布局属性时) 但也绝对不会绘制页面
                                等到js代码运行完以后才会绘制 parseInt('q we 123456 qweq ')获取第一个数字开始的连续数字
parseFloat()解析浮点





el.offsetWidth/Height 元素的border-box的宽高
el.clientWidth/Height 元素的padding-box的宽高

el.getBoundingClientRect()
 {
  top,left,right,bottom,width,height,x,y
 }
 表示元素的border box距离视口左上角的位置,x/y对于left和top,width/height对应于offsetWidth/Height
  获取包裹元素生成的所有矩形框的最小矩形框
  此处Bounding就是包裹,围住的意思
el.getClientRects() 获取行内元素生成的多个矩形框的数据

el.scrollLeft/Top 元素有滚动条时,元素内容水平及垂直滚动距离,可赋值以修改其滚动距离
el.scrollTo/By(x,y) 滚动到x,y位置/基于当前位置滚动x,y距离

window.scrollX/Y, window.pageX/YOffset 页面在窗口中的滚动位置,不可写
window.scrollTo/By(x,y) 滚动到x,y位置/基于当前位置滚动x,y距离

window.innerWidth/Height 视口宽度和高度



事件处理函数在处理哪个元素的事件，其this就是哪个元素
事件处理函数在处理哪种事件，其唯一参数的type就是哪种事件的事件名称
e.stopImmediatePropagation() // 当前元素上后续事件都不执行了

e.stopPropagation() // 阻止事件传到下一个元素上，但当前元素上剩余函数还会运行

el.matches(selector)
判断元素是否匹配一个css选择器






user-select: none;
让元素内的文字不可被鼠标选中





DOMMousescoll火狐的滚轮事件




async 属性：当浏览器遇到带有 async 属性的 <script> 标签时，它会立即开始下载脚本，并且不会阻塞页面的解析和渲染过程。
下载完成后，脚本将立即执行，而不管页面的加载状态。多个带有 async 属性的脚本之间的执行顺序不确定。


defer 属性：当浏览器遇到带有 defer 属性的 <script> 标签时，它会在页面解析完毕后，延迟脚本的执行，即脚本会在文档解析完成后按照它们在页面中的顺序依次执行。
                          defer 属性保证了脚本在文档解析期间不会中断页面的加载。


                          总结：

                          async 属性用于并行下载脚本，并在下载完成后立即执行，不阻塞页面加载。
                          defer 属性用于按照顺序延迟脚本的执行，直到文档解析完成，不阻塞页面加载。


                          preventDefault 是一个 JavaScript 方法，用于阻止事件的默认行为。
                          在事件处理函数中调用 preventDefault 可以阻止事件触发元素默认的行为或浏览器默认的行为。

                          例如，当点击一个链接时，浏览器默认会跳转到链接指定的 URL。
                          但是，如果在点击事件处理函数中调用了 event.preventDefault()，则可以阻止默认的跳转行为。





                          SyntaxError（语法错误）：代码包含了语法错误，例如拼写错误、缺少括号、分号等。这种错误会导致代码无法解析和执行。

                          ReferenceError（引用错误）：尝试使用未声明的变量或函数。这通常是由于变量名拼写错误、作用域问题或未导入所需的模块导致的。

                          TypeError（类型错误）：使用了错误的类型或对不支持某种操作的类型进行了操作。例如，对非函数类型的变量使用函数调用、对null或undefined值使用对象操作等。

                          RangeError（范围错误）：尝试使用超出有效范围的值。例如，数组索引超过数组长度、函数递归调用过深等。

                          DOMException：在使用DOM API时发生的异常。可能包括无效的参数、操作不允许、访问受限等。

                          NetworkError: Failed to fetch：由于网络问题或跨域访问限制等原因，无法成功获取资源。通常在使用AJAX请求或fetch API时遇到此错误。

                          SecurityError（安全错误）：尝试执行违反安全策略的操作。例如，跨域访问限制、对受限制的资源进行操作等。

                          InvalidStateError（无效状态错误）：尝试执行违反特定API状态的操作。例如，在不正确的时机调用API方法。

                          TypeError: Cannot read property ' x' of
                          undefined：尝试在undefined或null值上访问属性或方法。这通常发生在没有正确处理变量为空的情况下。 TypeError: Cannot set
                          property 'x' of null/undefined：尝试在undefined或null值上设置属性值。类似于上述情况，这通常发生在没有正确处理变量为空的情况下。
                          TypeError: is not a function：尝试调用一个不是函数的值。这可能是由于对非函数类型的变量使用函数调用或属性拼写错误等原因引起的。
                          document.createElement() 是一个用于创建新的 HTML 元素的方法。它接收一个参数，表示要创建的元素的标签名称 以下是一些常用的 <div>


                            DOM（文档对象模型）相关词汇： 1. 元素（Element）：HTML 或 XML 文档中的一个标签，如 `<div>`、`<p>` 等。

                              2. 节点（Node）：DOM 树中的基本单位，可以是元素、文本、注释等。

                              3. 根节点（Root Node）：DOM 树的最顶层节点，通常是 `<html>` 元素。

                                4. 父节点（Parent Node）：一个节点的直接上级节点。

                                5. 子节点（Child Node）：一个节点的直接下级节点。

                                6. 兄弟节点（Sibling Node）：具有同一个父节点的节点。

                                7. 文本节点（Text Node）：DOM 树中的文本内容。

                                8. 属性（Attribute）：HTML 或 XML 元素的附加信息，如 `class`、`id` 等。

                                9. 类名（Class Name）：元素的一个 CSS 类。

                                10. ID（Identifier）：元素的唯一标识符。

                                11. 选择器（Selector）：CSS 中用于选中特定元素的语法规则，如类选择器、ID 选择器等。

                                12. CSS 样式（CSS Style）：应用于元素的外观和布局规则。

                                13. 查询（Query）：使用 JavaScript 查找和选取元素的过程。

                                14. 集合（Collection）：返回多个元素的结果，如通过类名或标签名获取的元素集合。

                                15. 事件（Event）：文档或元素上发生的操作或交互，如点击事件、鼠标移动事件等。

                                16. 事件处理程序（Event Handler）：用于响应特定事件的 JavaScript 函数。

                                17. 监听器（Listener）：用于捕获和处理特定事件的代码。

                                18. 操作（Manipulation）：通过 DOM 接口修改文档结构或样式的过程。

                                19. 层叠样式表（CSS）：用于定义文档外观和布局的样式语言。

                                20. 动态（Dynamic）：通过 DOM 操作和 JavaScript 代码改变文档的行为和外观。

                                这些是 DOM 中的一些常见术语和概念，用于描述和操作网页文档结构。

                              </div>











                              BOM

                              操作浏览器历史记录：BOM的history对象提供了与浏览器历史记录交互的方法，如前进、后退页面等。
                              可以使用history.back()方法返回上一个页面，或使用history.forward()方法前进到下一个页面。

                              history.back(); // 返回上一个页面
                              history.forward(); // 前进到下一个页面



                              处理浏览器地址栏：通过BOM的location对象，可以获取和操作浏览器的URL和地址栏信息。
                              例如，可以使用location.href获取当前页面的URL，或使用location.replace()方法在不保留历史记录的情况下导航到新的URL。

                              console.log(location.href); // 输出当前页面的URL
                              location.replace('https://www.example.com'); // 导航到新的URL




                              操作文档对象：BOM的document对象提供了访问和操作当前加载的文档内容的方法和属性。
                              可以使用document.getElementById()方法通过元素的ID获取DOM元素，并对其进行操作。

                              var element = document.getElementById('myElement');
                              element.innerHTML = 'Hello, world!';





Base64编码
用文本来编码任意二进制数据
合理的选择是使用64个可打印符号来表示原始二进制数据
每个可打印字符表示6bit的原始数据
所以原始数据的第3节字节可以编码为4个字符的base64数据
‘abc’被编码为‘YWJj’
浏览器中自带编解码函数
atob解码
btoa编码



dataURL
以data:开头的url
可以在一个dataurl中表示一个文件的媒体类型及数据
dataurl可以填写在浏览可以识别的任何一个填写url的地方
如a[href], img[src], script[src]
div {
  color: red;
  background-image: url(dataurl)
}
@font-face {
  src: url(dataurl)
}
语法：
data:<mime-type>;<encode>,<data>
data:<mime-type>,<data>

data:text/html,<h1>hello world</h1>
data:text/html;base64,PGgxPmhlbGxvIHdvcmxkPC9oMT4=

data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMg9UHRsAAAC8AA

数据用base64编码后体积变大了，为什么还要这样做？
首先是变大了33.33%
但是对于较小的数据（如小于10k的文件）编码增加的量也很小
但当文件较小时，通过网络传输会小号的额外的流量，反而比编码为base64的额外字节要多


缺点：
  每次接收数据的一方都要先解码
  无法缓存

  所以一般不使用base64来编码以及传输较大的文件
  但是对于小文件是值得的






https




ipconfig /all
命令行查看网络配置

如何理解VPN？它工作在哪一层？
相当于从当前主机连接了一根网线到vpn服务器
当前主机会为此虚拟出一张网卡，并从vpn服务器那里获取ip配置信息
不同协议工作的层次不一样，有的工作在网络层，有的工作在链路层
但是其工作一般是基于传输层的udp协议的

IP数据包是如何到达目地址的？
是通过中间的路由设备相互转发到达的

IPv6如何在现行网络上工作？
通过一种叫ipv6 over ipv4的方式
当源地址发出一个ipv6的数据包后，数据包到达某个路由器后
它发现该数据包无法继续通过ipv6的方式转发了（如可能是因为达到目的地的过程中的必经路由不支持ipv6）
它会将该ipv6数据包放进一个ipv4数据包中，然后通过ipv4网络转发到某个支持ipv6的路由器
然后该路由器与目的ip之间可以通过ipv6通信
然后该路由器将ipv6数据包从该ipv4数据包解出来然后通过ipv6的方式转发到目的ip


DHCP是什么？其协商过程是怎样的？为什么会有租约时间的限制？
动态主机配置协议 Dynamic Host Configuration Protocol
客户端通过udp发送一个广播到67端口，内容为我需要一个ip地址配置信息
dhcp服务器收到后会回得给它一个ip配置信息的udp数据包
因为服务器可以分配的ip地址有限，因为一个局域网中可用的ip地址必然是有限的
如果光分配不回收，肯定会被用完
但“回收”从技术上讲不能强制执行，所以为ip地址设置了租约时间，在租约快要到期时客户端需要续约
为什么不能在客户端离开网络时自动告诉服务器释放ip？
因为当客户端发现自己离开网络时，已经来不及了


物理层、链路层、网络层分别主要关心的是什么？
物理层关心双方能够有效的通信，即至少能相互发送和接收01信号
链路层关心【直接连接】的设备间的通信，以“以太网帧”为单位，即链路层数据包
网络层关心所有直接或间接连接的主机间的通信（但注意，只关心主机到主机之间）



什么是MTU？典型值是多少？什么情况下其大小不是典型值？
Max Transfer Unit 最大传输单元
指的是一个数据包中最多可以放多数据

链路层的MTU是1500字节
网络层的MTU一般是1480字节，即链路层的mtu减去网络层的头部20个字节

在一些特殊情况下，其值可能不会典型值，如vpn连接





带宽与延迟分别代表什么？说出常见应用更关注带宽还是延迟。
带宽指单位时间能够传输的数据量
（发送方用1s发送了1M的数据，经过一定的时间，接收方也使用大约1s的时间接收这1M的数据）
类似于水管的粗细，或道路的宽度

延迟是，发送出数据后，接收方多久收到这个数据
类似于道路或水管的长度

更关注带宽的：
  在线电影
  迅雷下载

更关注延迟的：
  游戏
  通话
  即时消息（qq）


用手机流量连接教室vpn以实现查看我电脑上的共享文件。


DNS服务是什么？其沟通过程是怎样的？为什么不能用域名的方法指定DNS服务器？能否在某台机器上改变一个域名的指向？如何操作？
域名解析，用来查询域名对应的ip址的服务
其沟通过程是“请求/响应”，即dns客户端向dns服务器发送查询请求，服务回复查询响应
如果用域名来指定，则该需也需要解析，然而解析出来之间并不知道dns服务器的ip，所也无法连接到它

能否在某台机器上改变一个域名的指向？如何操作？
通过修改hosts文件:
  windows: C:\Windows\System32\drivers\etc\hosts
  linux/m: /etc/hosts


请说出UDP协议的通信模型。
  每个udp套接字都可以绑定在当前主机的一个端口上，并在该端口侦听
  它可以接收到其它udp套接字发来的数据
  也可通过该端口向任何udp套接字发送数据
  可以说每个udp套接字都是对等的
  它不存在连接
  数据不保证送达
  也不保证先到的数据一定先发的



如何可以知道某台机器的某个udp端口是否打开？
  向该端口发送udp数据包，如果收到回应则证明它打开了
  否则无法确定
为什么DNS服务器的地址一般都比较好看好记？
  因为dnv服务器的ip址就是为了让人记住，所以专门选的好记的地址

0.0.0.0与255.255.255.255这两个地址在不同情况代表什么？
  0.0.0.0：在某主机还没有ip地址的时候，它可以用来代表自己的地址（如dhcp协议中）
  在端口侦听的时候，可以用代表自己所有的地址

  255.255.255.255代表广播地址

什么是NAT？它的目的是？
  Network Address Transform 网络地址转换
  目的是解决ipv4地址不够用的情况
  nat路由器会将发出的数据包的源地址改为自己的ip
  会将收到的数据包的目的地址改为其背后的某台主机的ip
  其一般会通过端口来区分收到的数据包应该转发给其背后的哪台主机
  所以它在运行过各中会动态建立一个端口映射表
    来记录从某个端口收到的数据包应该发给内部的哪个主机的那个端口

NAT会产生什么副作用？

  如果nat背后一台主机在某个端口侦听，但并未通过该端口发送过数据
  则它并不能通过该端口收到来自路由器外网的数据包
  因为路由器收到后也不知道该发给内网的哪个主机

  对内部主机形成了某个网络攻击的保护
  因为不知道名的数据包会直接被nat路由丢弃

如何知道自己的电脑是否处于NAT网络中？
  通过命令知道自己电脑的ip
  然后通过ip138类似的网站知道自己公网ip
  看两个ip是否相同，如果不同，则说明自己的主机在nat网络中

到阿里云或其它服务商申请一个域名并将一个子域名指向某ip地址。









查询计算机网络配置信息的命令是什么？
  windows: ipconfig
  linux/max: ifconfig   (interface config)
ping命令做了什么？抓包查验证。
  向目标主机发送了若干个表示“你在吗？”的ICMP数据包
  并等待对方回应且显示相关的统计信息
  可以检测两个主机之间是否在网络层连通
什么是mac地址？
  Media Access Control地址
  网卡地址，或硬件地址，hardware address
  是网卡出厂时自带的一个全球唯一的一个地址
  将用于在总线形（集线器，交换机）网络中标识直接连接主机
  即直接连接的主机之间收发数据包将会用该地址标识收发方
  长度是6个字节，一般写成12位的十六进制数（每个字节用中划或冒号连接）

交换机于集线器有什么区别？
  集线器相当于就是一个总线，它在任何端口收到的数据，都会从所有其它端口发送出去
  所以任何一个主机发送数据，该集线器上所有其它主机都能收到
  即使该数据只需要发给某一个主机
  对线路的利用率很低，因为任何一个时刻都只能有一台主机在发送

  交换机则优化了对线路的使用
  交换机的每个接口知道该接口连接网卡的物理地址/mac地址
  当数据包经过其某个端口发送时，它会识别数据包中的接收方的物理地址
  并将数据包只发给那个主机
  不影响所有其它的主机之间的通信

  但是对于连接到交换机上的所有主机来说，是否连接到交换机对于主机来说是透明的
  即主机可以认为自己依然连接在总线上，可以按照连接到总线上的方式工作

  交换机是根据数据包中的mac地址来转发数据包的，且不能识别包内的内容
  所以交换机是一个二层设备，即工作在数据链路层

  集线器是哪一层的？
    物理层

交换机的接口有mac地址吗？为什么？
  没有
什么叫网管交换机？
  即三层交换机，但并不是工作在第三层，而是它能够识别数据包中第三层即网络层的数据
  最关键的就是ip数据包中的两个ip地址，即源ip和目的ip
  且根据这个识别到的数据对数据包做一定的管理
  如：它可以限制其一个端口上连接的主机“声称”自己有多个ip地址，而只允许它“声称”自己有一个ip地址
      当它“声称”自己有另外的ip地址时，网管交换机不转发该数据包
何为载波帧听多路访问？
  载波帧听：
    就是在发送数据的时候同时帧听是否有其它设备也在发送
    如果有，则是产生了冲突，则数据无法正确发送

  多路访问：
    同一个线路上有可能有多个设备同时使用它

为何要使用曼彻斯特编码？
  如果使用最简单的高低信号来表示01或10
  那么当发送多个连续的0或1的时候，
  电信号将持续为高或低一段时间，
  由于误差的存在，接收方可能无法正确区分出这一段连续的高或低信号代表多少0或1
  所以我们需要一种能够在信号中携带时间信号的编码方式
  而曼彻斯特编码则可以让信号在每个bit都进行一次跳变
  即使是连续的0或1或任意的01序列，电信号都不会很久不发生跳变

为何要做时钟同步？
  因为双方的时钟可能速度不一样

网络与快递的相似之处体现在什么地方？
  分层设计
    网购/xx依赖快递
    快递依赖车
    车依赖路

  拓扑结构相似
    都是在末端为树状结构
    而在主干上是网状结构

  转发过程也相似
    不管是数据包
    还是快递包裹
    都是被相邻的结点慢慢转发到目的地的

  地址也有一定程度的类似：
    相同地区的地址比较相近
    而相同地区网络设备的ip地址也比较接近

为什么ip地址是按地区划分的？
  网络设备在在于物理世界的各个不同地区的
  那么，网络设备在转发数据包时，肯定会把到达同一地区的数据包从同一端口出
  而显然，它不可能精确记录每个不同的ip地址从哪个口出去
  而是会像快递一个，只看包裹到哪个省或哪个市即可决定从哪个口出
  而路由器们，则是看ip地址部分前缀来决定数据包的走向
  那么必然，走向同一个方向的数据包，目的ip的前缀是相同或相似的
  最终的结果就是相同地址的ip地址相近，且一部分前缀相同

实验两台电脑直接使用网线连接，设置合适的ip地址后相互ping通。


实验连接在同一交换机的电脑设置不同网络的ip地址是无法相互ping通。

抓包查看并验证tracert的原理。




请说出UDP协议的通信模型。
每个udp套接字可以绑定在某个端口上
所有的udp套接字之间可以直接互发消息
不需要建立连接
数据不保证送达，也不保证先发的先到
前后发送的数据在udp看来也无关
所有udp socket之间是对等的

请说出TCP协议的通信模型。
服务器程序在某个tcp端口侦听
多个客户端可以向此侦听端口建立连接
连接建立成功后相当于一个双向数据通道
发送的数据能够保证按序送达
服务器跟客户端不是对等的

如何可以知道某台机器的某个udp端口是否打开？
向该udp端口发送消息，如果能得到回应由说明打开的
否则是不能确定

如何查看当前系统中打开的TCP连接？
windows: netstat -nao  ,   资源监视器
linux:
ss -n -p 所有tcp连接及其状态，-p是显示对应连接所属的进程id，
-n表示用数值显示端口号


如何查看当前系统中正在侦听的TCP服务端口及UDP端口？
ss -l
netstat -nao
资源监视器


TCP头部的序列号和确认号分别代表什么？
序列号表示此数据包的数据部分的第一个字节是发送方总发送的第几个字节
确认号代表接收方已经接收到确认号之前的所有字节
  或接收方还未接收到确认号开始的字节，但【并不代表】该字节之后的所有数据都未接收到


为什么建立TCP连接需要三次握手？断开时需要四次挥手？
  因双方进行一次有效的信息交换至少需要3次成功的单向沟通
  断开时需要四次挥手？ 因为tcp连接是支持半开的，双方要分别结束连接，而双方也要分别向对方发送ack，所以一共是四次
    但是也可能是三次：发fin，收ack+fin，发ack

TCP协议关注的重点是什么？
  面向连接
  数据的按序可靠送达



为什么红蜘蛛软件人多也不卡？但有可能花屏？
  因为它是用的udp广播的方式传输数据的，跟人数基本上没关系

  花屏是因为udp不是可靠传输，数据可能丢失，而它可能又没有重传机制

为什么另一个投屏软件人多就会卡？
  因为它使用的是tcp协议
  数据是分别发给每个接收方的，不是广播，接收方太多，发送所需带宽就会很高
    当带宽达不到需要的值时，就会卡
    当带宽不足时，除了丢包，由于tcp的队头阻塞，先到的数据（如果其前面的数据还未到）也不能被显示

为什么不建议使用无线网络接收画面？
  因为无线网络一个机器发，其它所有的机器都只能收


有一个协议叫NTP，意为网络时间协议，用来对系统进行对时，不查网络，请问你觉得它基于什么协议？
  使用的是udp
  1 对时应该不需太多数据量，那么一个udp数据包应该是能放得下
  2 对时需要网络延迟越低越好，而tcp需要建立连接，连接建立之后才能发送数据
  3 万一丢包了，下层tcp还会重发，会导致对延迟的计算更加不准确


为什么DNS协议不基于TCP而要基于UDP？
  dns协议并不需要发送太多数据，dns查询的问题可以放进一个udp数据包中，回复也是
  udp完全够用。

  实际上现在dns也有基于tcp的实现和基于https的实现。
    防止被劫持：即中间设备伪造数据包返回错误的ip地址

为什么另一些协议需要基于TCP？
  因为它们需要可靠传输
  如果它们基于udp，则它们需要自行实现可靠传输


如何知道一台机器的某个端口是否有TCP Server正在侦听？
  尝试连接，如果能连接成功说明肯定在侦听

TCP连接时出现的CONNECTION_REFUSED和CONNECTION_TIME_OUT以及CONNECTION_RESET报错分别代表什么意思？
  连接被拒绝：服务器ip地址存在，服务器也存在，但没有程序在对应端口侦听
  连接超时：客户端（主动发起连接的一方）在一定的时间没有收到任何回应；说明ip地址可能写错了
  连接被重置：接收方收到了RTS被置为1的tcp包，说明对方认为连接已经不可持续了

什么是TCP协议的粘包？上层应该如何处理这种情况？
  多次发送的数据可能被一次性收到
  也即接收方无法区分数据是如何被分段发送的。

  自行在发送的数据中以自己的方式标记出每段数据的长度


FTP为何基于TCP而不是UDP？
  因为ftp需要可靠传输且数据量很大

FTP中传输数据时为什么要新开一个TCP连接？
  新开的连接发数据
  原来登陆用的连接发指令
  即使数据没发完，也不影响指令的送

tcp服务器在同一个端口收到来自不同客户的数据包，它是如何区分的呢？
  通过发送方的ip和端口，来自同一ip:port的数据会归为一个连接上的数据包








如何理解VPN？它工作在哪一层？
相当于从当前主机连接了一根网线到vpn服务器
当前主机会为此虚拟出一张网卡，并从vpn服务器那里获取ip配置信息
不同协议工作的层次不一样，有的工作在网络层，有的工作在链路层
但是其工作一般是基于传输层的udp协议的

IP数据包是如何到达目地址的？
是通过中间的路由设备相互转发到达的

IPv6如何在现行网络上工作？
通过一种叫ipv6 over ipv4的方式
当源地址发出一个ipv6的数据包后，数据包到达某个路由器后
它发现该数据包无法继续通过ipv6的方式转发了（如可能是因为达到目的地的过程中的必经路由不支持ipv6）
它会将该ipv6数据包放进一个ipv4数据包中，然后通过ipv4网络转发到某个支持ipv6的路由器
然后该路由器与目的ip之间可以通过ipv6通信
然后该路由器将ipv6数据包从该ipv4数据包解出来然后通过ipv6的方式转发到目的ip


DHCP是什么？其协商过程是怎样的？为什么会有租约时间的限制？
动态主机配置协议 Dynamic Host Configuration Protocol
客户端通过udp发送一个广播到67端口，内容为我需要一个ip地址配置信息
dhcp服务器收到后会回得给它一个ip配置信息的udp数据包
因为服务器可以分配的ip地址有限，因为一个局域网中可用的ip地址必然是有限的
如果光分配不回收，肯定会被用完
但“回收”从技术上讲不能强制执行，所以为ip地址设置了租约时间，在租约快要到期时客户端需要续约
为什么不能在客户端离开网络时自动告诉服务器释放ip？
因为当客户端发现自己离开网络时，已经来不及了


物理层、链路层、网络层分别主要关心的是什么？
物理层关心双方能够有效的通信，即至少能相互发送和接收01信号
链路层关心【直接连接】的设备间的通信，以“以太网帧”为单位，即链路层数据包
网络层关心所有直接或间接连接的主机间的通信（但注意，只关心主机到主机之间）



什么是MTU？典型值是多少？什么情况下其大小不是典型值？
Max Transfer Unit 最大传输单元
指的是一个数据包中最多可以放多数据

链路层的MTU是1500字节
网络层的MTU一般是1480字节，即链路层的mtu减去网络层的头部20个字节

在一些特殊情况下，其值可能不会典型值，如vpn连接





带宽与延迟分别代表什么？说出常见应用更关注带宽还是延迟。
带宽指单位时间能够传输的数据量
（发送方用1s发送了1M的数据，经过一定的时间，接收方也使用大约1s的时间接收这1M的数据）
类似于水管的粗细，或道路的宽度

延迟是，发送出数据后，接收方多久收到这个数据
类似于道路或水管的长度

更关注带宽的：
  在线电影
  迅雷下载

更关注延迟的：
  游戏
  通话
  即时消息（qq）


用手机流量连接教室vpn以实现查看我电脑上的共享文件。


DNS服务是什么？其沟通过程是怎样的？为什么不能用域名的方法指定DNS服务器？能否在某台机器上改变一个域名的指向？如何操作？
域名解析，用来查询域名对应的ip址的服务
其沟通过程是“请求/响应”，即dns客户端向dns服务器发送查询请求，服务回复查询响应
如果用域名来指定，则该需也需要解析，然而解析出来之间并不知道dns服务器的ip，所也无法连接到它

能否在某台机器上改变一个域名的指向？如何操作？
通过修改hosts文件:
  windows: C:\Windows\System32\drivers\etc\hosts
  linux/m: /etc/hosts


请说出UDP协议的通信模型。
  每个udp套接字都可以绑定在当前主机的一个端口上，并在该端口侦听
  它可以接收到其它udp套接字发来的数据
  也可通过该端口向任何udp套接字发送数据
  可以说每个udp套接字都是对等的
  它不存在连接
  数据不保证送达
  也不保证先到的数据一定先发的



如何可以知道某台机器的某个udp端口是否打开？
  向该端口发送udp数据包，如果收到回应则证明它打开了
  否则无法确定
为什么DNS服务器的地址一般都比较好看好记？
  因为dnv服务器的ip址就是为了让人记住，所以专门选的好记的地址

0.0.0.0与255.255.255.255这两个地址在不同情况代表什么？
  0.0.0.0：在某主机还没有ip地址的时候，它可以用来代表自己的地址（如dhcp协议中）
  在端口侦听的时候，可以用代表自己所有的地址

  255.255.255.255代表广播地址

什么是NAT？它的目的是？
  Network Address Transform 网络地址转换
  目的是解决ipv4地址不够用的情况
  nat路由器会将发出的数据包的源地址改为自己的ip
  会将收到的数据包的目的地址改为其背后的某台主机的ip
  其一般会通过端口来区分收到的数据包应该转发给其背后的哪台主机
  所以它在运行过各中会动态建立一个端口映射表
    来记录从某个端口收到的数据包应该发给内部的哪个主机的那个端口

NAT会产生什么副作用？

  如果nat背后一台主机在某个端口侦听，但并未通过该端口发送过数据
  则它并不能通过该端口收到来自路由器外网的数据包
  因为路由器收到后也不知道该发给内网的哪个主机

  对内部主机形成了某个网络攻击的保护
  因为不知道名的数据包会直接被nat路由丢弃

如何知道自己的电脑是否处于NAT网络中？
  通过命令知道自己电脑的ip
  然后通过ip138类似的网站知道自己公网ip
  看两个ip是否相同，如果不同，则说明自己的主机在nat网络中

到阿里云或其它服务商申请一个域名并将一个子域名指向某ip地址。








非对称加密的特点是什么？它能实现哪些看似难以完成的任务？
  加密与解密用的不是同一个密钥
  公钥加密用私钥解密,私钥加密用公钥解密
  速度慢
  可以做到事件不交换对称密码,让其它人给自己发消息时也无法被中间人知道

  利用非对称加密实现的电子签名
  以及基于电子签名的证书与信任链


什么是对称加密?它与非对称加密的区别是?
  加密与解密用的是同一个密码
    如异或加密
    aes-256

  速度快,适合加密大量数据



公钥与私钥一般分别用来做什么?
  公钥加密,私钥解密
  私钥签名,公钥验证


证书中包含什么信息？为什么它不可伪造和篡改？并且其它人拿了也没用？
  签发机构
  证书的内容,即要证明的事情
    证明远程计算机的身份
    向远程计算机证明你的身份
    确保软件来自软件发布者
  证书所有人的公钥
  有效期
  使用的哈希算法
  对以上信息的签名

  内容如果被修改,由签名对不上
  伪造的话,无法伪造签名,因为没有其它人的私钥

  拿了但不经过任何修改,出示时证明的不是自己的身份,是其它人的身份



证书是从哪里来的?它是如何被签名的?
  是由CA机构验证完事实以后向申请者颁发的

  对证书的内容计算哈希值(如使用md5,sha1,sha384,sha512)
  用私钥对该哈希值进行加密
  加密结果即为签名

  如何验证签名?
    用公钥对签名进行解密
    对证书主体内容进行哈希值的计算
    用计算出来的哈希值与解密结果做对比
    如果相同则通过验证


为什么HTTP协议基于TCP而不是UDP?
  因为http可能发送大量数据
  当然需要可靠转输
    要么基于tcp
    要么基于udp自己实现可靠传输

  QUIC(未来的http3)是基于udp的


TLS协议是什么?握手阶段双方交换了什么信息?
  传输层安全 Transportation Layer Secure

  交换了证书,公钥,加密算法,协商出来的对称加密的密码


TLS能够保障通信哪些方面的安全?
  保证我们想连接的对方就是我想连接的对方
  通信数据不被篡改
  通信数据不被窃听


TLS是固若金汤的吗?如果不是,哪些环节存在突破点?
  不是
  ca机构如果黑客发放不属于他的证书
  证书持有者的私钥泄露,则其它人拿着证书与证书对应的私钥就可以冒充原证书持有者
  计算机上安装的根证书被增加
  程序在对算法的实现存在漏洞


HTTP协议的通信模型是?与FTP的通信模型有何区别?与DNS协议的通信模型有什么区别?
  请求/响应模型
    连接建立后,客户端发送请求,服务端接收到请求后发送响应,一次http通信结束.连接即可关闭

  ftp是连续对话模型
    连接建立后在连接上连续对话,多数对话也是会有对方响应的

  dns也是请求/响应模型
    客户端发送dns查询请求,服务回复查询结果.
    它基于udp是因为查询与响应数据量都足够小,一个udp数据包放得下

HTTPS是什么意思?是否可能存在FTPS协议或者其它的xxxS协议?
  http over tls,即基于tls协议的http
    即在安全连接上发送http报文

  存在的
    多数基于tcp的协议都存在基于tls协议的版本

    ftps
    ws  的安全版本   wss


写分别出HTTP协议请求的格式与响应的格式

```
请求方法 请求地址 协议版本
头1: 值1
头2: 值2
头3: 值3

请求体
```
