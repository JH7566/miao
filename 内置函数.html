<script>

1.this的一些使用

f(a,b,c){
  return a + b + c + this
}
f.apply(this(可以写空null),[1,2,3])
得到 1+2+3+this = 6


f2 = f.bind(1(this),2(a))第一个参数代表this，第二个为a
f2(3(b),4(c))所以只需要传入剩下的b和c两个参数，结果还是this和abc相加
得到 1+2+3+4 = 10

f.call(1, 2,3,4)规定死了 == f.apply(1, [2,3,4])数组更灵活



2.关于原型prototype
Object.create(o) // 创建以o为原型的新的空对象
Object.getPrototypeOf(obj) // 获取obj的原型
以前等价于 obj.__proto__

Object.setPrototypeOf(obj, target) // 设置obj对象的原型为target
以往等价于 obj.__proto__ = target

现在当obj最终以Object.prototype为原型时，也是等价的
但当obj没有原型或并不最终以Object.prototype为原型时，则不等价

</script>



<script>
  /**
 * initialize your data structure here.
 */
var MinStack = function() {
  this.stack = []; // 初始化数组用于实现栈
  this.minStack = [Infinity]; // 初始化数组minStack，用于保存栈中元素的最小值，初始值为无穷大，保证第一个被插入栈中的元素为最小值
};

/**
 * @param {number} val
 * @return {void}
 */
MinStack.prototype.push = function(val) {
  this.stack.push(val); // 在栈中加入元素
  this.minStack.push(Math.min(this.minStack[this.minStack.length - 1], val)); // 将新元素的值与当前最小值进行比较，将较小的值插入minStack中
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  this.stack.pop(); // 弹出栈顶元素
  this.minStack.pop(); // minStack也需要弹出元素，以保证和stack同步
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  return this.stack[this.stack.length - 1]; // 返回栈顶元素
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  return this.minStack[this.minStack.length - 1]; // 返回栈中最小元素
};





class Twitter {
  // 初始化一个空的用户推特对象
  constructor() {
    this.users = {};
  }

  // 创建一条新推特
  postTweet(userId, tweetId) {
    // 如果用户不存在，则创建一个新用户
    if (!this.users[userId]) {
      this.users[userId] = {
        tweets: [],
        followers: new Set(),
      };
    }

    // 向用户的推特列表中添加新推特
    this.users[userId].tweets.unshift(tweetId);
  }

  // 检索当前用户新闻推送中最近 10 条推文的 ID
  getNewsFeed(userId) {
    const tweets = [];

    // 获取当前用户和其关注的用户的最新 10 条推特
    if (this.users[userId]) {
      tweets.push(...this.users[userId].tweets.slice(0, 10));
    }
    for (const followerId of this.users[userId].followers) {
      if (this.users[followerId]) {
        tweets.push(...this.users[followerId].tweets.slice(0, 10));
      }
    }

    // 按时间顺序排序并返回最新 10 条推特的 ID
    return tweets
      .sort((a, b) => b - a)
      .slice(0, 10);
  }

  // 开始关注某个用户
  follow(followerId, followeeId) {
    // 如果关注者不存在，则创建一个新的关注者
    if (!this.users[followerId]) {
      this.users[followerId] = {
        tweets: [],
        followers: new Set(),
      };
    }

    // 添加关注信息到关注者的关注列表中
    this.users[followerId].followers.add(followeeId);
  }

  // 取消关注某个用户
  unfollow(followerId, followeeId) {
    // 如果关注者存在，则从其关注列表中移除对应用户
    if (this.users[followerId]) {
      this.users[followerId].followers.delete(followeeId);
    }
  }
}








// 定义节点类
class Node {
  constructor(key, val) {
    this.key = key;
    this.val = val;
    this.prev = null;
    this.next = null;
  }
}

/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
  this.capacity = capacity;
  this.size = 0;
  this.cache = new Map(); // 用于缓存键值对
  this.head = new Node(); // 虚拟头节点
  this.tail = new Node(); // 虚拟尾节点
  this.head.next = this.tail;
  this.tail.prev = this.head;
};

/**
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  if (this.cache.has(key)) { // 如果缓存中有该节点
    const node = this.cache.get(key);
    this.moveToHead(node); // 将该节点移动到头部(代表最近访问过)
    return node.val;
  }
  return -1;
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  if (this.cache.has(key)) { // 如果该节点已存在，更新值并移动到头部
    const node = this.cache.get(key);
    node.val = value;
    this.moveToHead(node);
  } else { // 如果该节点不存在，新建节点插入链表头部
    const newNode = new Node(key, value);
    this.cache.set(key, newNode);
    this.addToHead(newNode);
    this.size++; // 缓存节点数加1
    if (this.size > this.capacity) { // 如果节点数超过容量上限
      const tail = this.removeTail(); // 移除链表尾部节点
      this.cache.delete(tail.key); // 从缓存中删除该节点
      this.size--; // 缓存节点数减1
    }
  }
};

// 辅助函数：将节点插入头部节点后面
LRUCache.prototype.addToHead = function(node) {
  node.prev = this.head;
  node.next = this.head.next;
  this.head.next.prev = node;
  this.head.next = node;
};

// 辅助函数：移除指定节点
LRUCache.prototype.removeFromList = function(node) {
  node.prev.next = node.next;
  node.next.prev = node.prev;
  node.prev = null;
  node.next = null;
};

// 辅助函数：将指定节点移动到头部节点后面
LRUCache.prototype.moveToHead = function(node) {
  this.removeFromList(node);
  this.addToHead(node);
};

// 辅助函数：移除尾部节点
LRUCache.prototype.removeTail = function() {
  const node = this.tail.prev;
  this.removeFromList(node);
  return node;
};
</script>
