
cursor: pointer;鼠标手



# 学习内容
## 3.15
* 命令行基础
* # powershell # dir
* ls 显示文件夹里的文件
* GUI VS CLI
* GUI-GRaphael User
* Interface,图形化**用户**界面/接口
* GLI-Commad Line Interface,
* cat ***.txt(显示文件内容)
* 不同的操作系统命令行都有区别
* Subsystem 子系统
* 命令行最重要的两个概念
* 当前工作目录（）
* ~ 代表当前工作主目录 (.我的文档)
* *pwd 看当前工作目录完全打开
* 命令行按回车键显示的是提示行
* 路径 （列表），Path
* 运行 echo ＄PATH 显示路径列表
* prompt 命令 提示符
* 命令的基础
* 命令名 参数1.2.3.4
* 参数是可选的
* 一般命令，裸命令
* cd change Directory 改变工作目录
* # command not found # 命令未找到
* pwd, clear,ls,cd,exit
* 带选项/参数的命令
* # npm --help # 看说明书
* ls -h -a
* ls -help 帮助
* ls -l -h
* 不同的顺序效果不同
* -h # human readable# 人类可读的
* -a all所有
* 不同软件符号代表含义不同
* ls -a -h -l可以等于ls -ahl
* babel a.js -o=a.compilde.js 更改这个文件并输出到新的文件里
* 将命令的输出追加到文件
* echo def >> foo.txt
* 将命令输出到文件
* echo
* 快捷键
* Tap 自动补全命令
* ctrl+C 强行停止当前运行
* ctrl+A 将光标移动到最前
* ctrl+E 将光标移到最后
* ctrl+L 清屏
* ctrl+R 搜索命令历史

* 常用命令
* cat
* cat file1.txt. file2.txt file3.txt
* 将文件拼接到文件 files.txt
* echo 回显
* change Directory改变工作目录
* cd 绝对路径
* cd 相对路径（相对于当前文件夹）
* ..代表上一级目录
* .代表当前目录
* 从左往右读遇到..将它和左边的路径片段一起删除，遇到.只删除它本身
* rm 删除文件
* cp copy 复制
* mv ole new 移动重命名
* touch a.txt 创建空文件 修改文件时间
htop文件管理器
* time

* 有趣的命令
* sl 火车
* nudoku 数独
* fortune名言
* cowsay hello
* lolcat 把输出变成彩色
* 同时用间隔需要|
* termux 安卓下载软件可用
* ## vi
* 基础使用
* 达到可以在vps上编辑文本文件即可
* esc 从编辑模式返回常规模式
* i 常规模式下进入编辑模式
* ：wp常规模式下输入，保存并退出
* ：q！不保存且强制退出
* Jkhl 在常规模式下相当于上下左右
## 文本文件与二进制文件
* 文本文件
* txt/ini/cfg/html/css/.gitignore
* 可以被文本编辑器直接编辑

**二进制文件**
* 区别在于不能用文本编辑器打开，打开是乱码
## markdown 用来写简易文档
* markdown语言
* 轻量
* 是一种基本的**标记语言**（不是编程语言没有逻辑只能表达信息）
* 纯文本
* 带格式
* 语法
*

# 记笔记软件
* onenote
* notaion
* word



# 3.16笔记
- 程序中的空格是无效的
- Markdow 每一行前面的>可以同时引用

## GIT(git)

git init 创建初始化仓库

git add ***.txt 把文件放到暂存区

git commit -m 'initial commit'提交

git status 查看文件状态 function quickSort7(array, start = 0, end = array.length - 1) {
  //end和start相等的时候返回上一层
  if (end - start < 1) {
    return array
  }
  var 哨兵元素的下标 = Math.floor((end - start) * Math.random() + start)
  var 哨兵元素 = array[哨兵元素的下标]
  //i指向小于哨兵元素的最后一个
  //k指向大于哨兵元素的第一个
  var i = start - 1
  var k = end
  for (var j = start; j <= k; j++) {
    if (array[j] < 哨兵元素) {
      i++
      swap(array, i, j)
    }
    //大于哨兵元素的放在后面
    if (array[j] > 哨兵元素) {
      swap(array, j, k)
      k--
      j--
    }
  }
  //当结束后,哨兵元素的前半截为start, i,后半截为,k+1,end
  quickSort5(array, start, i)
  quickSort5(array, k + 1, end)
  return array
}


git diff 查看更改

git add .把当前文件夹所有文件添加到暂存区

git log 日志


CRLF 回车字符win系统



## commit 一个提交
## fatal 严重错误
# ssh-keygen 生成公私钥吗，找到公钥添加到GitHub账户里，之后这台电脑







git remote add github git@github.com:xieranmaya/learn-git10.git
添加远程创建并起名字


git remote 查看添加过哪些远程仓库

git remote remove name 删除远程仓库

git remote set-url name url 修改某个名字对应的仓库地址

git remote --verbose 查看添加过哪些远程仓库及其地址

git push repo_name branch_name
将分支推送到远程同名分支，远程如果没有会创建

git push -u repo_name branch_name
将分支推送到远程同名分支并建立绑定关系

git push
将当前分支推送到其绑定的远程分支上去

git clone 克隆远程地址文件夹

ssh-keygen 生成公私钥对
找到公钥添加到github账户里
后续这台电脑与github服务器的通信都会通过公私钥,不再需要输入密码了

# 3.17
# 浏览器
* 自主内核浏览器 自主研发的内核 目前只有Chrome谷歌和Firefox火狐
* TE->EDGE/Chrome/Firefox/Safari/Opers
* 壳浏览器 套壳别人的内核

# HTML
* 引入
* 与Markdown一样都是标记语言
* 嵌套规则
* 与数学公式基本一模一样
*





* <p></p>paragraph 段落
* 成对出现，开始标签和结束标签<></>
* <kdb></kdb> 用键盘等宽字体



# 3.20
**HTML属性**
'<div xxx="yyY">'属性'xxx'不区分大小写,属性值'yyy'区分大小写
  * 属性值一般用双引号，也可以用单引号，不用也可以，一般用双引号
  ## HTML
  ### 标签介绍
  * <html>

  </html>一个网页只能出现一个，出现在外层
  *
  <!DOCTYPE HTML>文档类型标明，出现在最前面
  *

  <head>
    放页面标题, <title>公司首页</title>只能放文字
    <link rel="icon" href="图标网址">标题的小图标href=src(source)
    作者
    *

  <body>
    <h1>一级标题</h1>
    页面显示的文字放在这里
    <p>表示段落</p>
  </body>

  *编码方式-uft-8
  <mate charset="UTF-8">


    </head> 头部标签
    * 样式表
    <style>
      /<link rel="stylesheet" href="a.ss"
      ## viewport 视口可以调整 < !DOCTYPE HTML>不会自动生成 <html><head></head>标题 <body>页面内容 <div></div></body><p></p>段落 <script></script></html><div></div>标题 <h1></h1><h2></h2>.. .. .. <h6></h6>一到六级标题 <strong>加粗强调标签</strong>### SEO 搜索排名优化Search Engine Optimisim * 如何布置页面让其在搜索结果中靠前 * 比如关键字 * 页面被引用的次数（反向链接数量） * 交换链接 * 使用https: //    s=seceye 安全
      * 使页面的html更符合语义 * HTML5中新增了hgroup(hearder group)标签 ...html <hgroup><h1>主标题</h1>主标题包裹副标题 <h2>副标题</h2></hgroup>... # p标签 * p标签表示段落 <p></p>里面不能出现另一个<p></p><p id="#p5">从a标签的#p5跳转到此 * a标签表示锚 <a href="链接地址">文字</a>* <a href="#p5">直接跳转到p5段落 页面内 # a标签 * <a href="../../../a/b/index.html"></a>* <a href="http://a.com/a/b/index.html"></a>* 相对路径将路径与网址直接拼接为http: //a.com/a/b/../../../a/b/index.html再相约为http://a.com/a/b/index.html

      * <a href="/a/b/index.html"></a>* <a href="http://a.com/1/2/index.html"></a>* 绝对路径直接从网址第一个单斜杠后直接拼接http: //a.com/a/b/index.html

      * href空的="" 指向当前页面自己而不是文件夹 * target="新窗口打开_blank" 如果没有_<a href="http://a.com/1/2/index.html" target="333">则会寻找或者创建一个333的界面打开网址<a href="http://a.com/1/2/index.html" target="333>不会打开多个页面，而是在固定的333网页打开

      * <a href="http://www.mi.com/1/2/index.html" 加上一个download <a href="http://www.mi.com/1/2/index.html" download="小米.pdf">则会下载自家网站的文件：小米.pdf # img标签 * 图片标签 * <img src（source）="图片地址" alt（alternative替代品，另外选项）="图片未加载成功用这里的文字替代">* <img src="" alt="">* <img src="" alt="" width="" height="">设置宽高固定图片位置尺寸width="" height=""

      * id="fool" 页面内跳转，fool不能重复 * id="" 一般是单一的词，不以数字开头，没有空格 * title属性，鼠标指向显示tooltip * <img alt="" title="" src="xxx.jpg">alt="" 是图片加载不出来替换图片，title="" 是描述文本鼠标移动到图片显示信息，以及更多用处 * <p class=""></p>更改样式 * <span style="xxx xxx xxx"></span>CSS更改样式格式等 * <a href="" tabindex="跳转顺序123" target="_blank">文本</a>* <p contenteditable>contenteditable页面内内容可编辑 <p data-xxx（=后面信息的含义）="你想表达的信息">自己想加标签的属性的话必须加上date- <div isbn="123456">书籍详情</div># span 标签 * <span class="sprce">100.00</span>没有明确的语义 * <div class="">也没有明确的语义 * <br/>自闭和标签，换行作用，/可以不加 * <hr>结束标签 * <base target="_blank" />在<head></head>里使用，只出现一次 * <font color="颜色" size="字号" face="字体">文字</font><marquee behavior="左右" direction="上下"></marquee>字体滚动 * em 强调 * strong 更重的强调 * b bold 加粗 * u underline 下划线 * i itliic 默认为斜体，区分文本 多数网站用来做图标 < !-- 文字 -->html注释 * 小于号&lt;
      span>&gt;
      大于号 ## &name ## &#number;
      十进制 ## &#xHHHH;
      十六进制 ## &nbsp;

      160号空格 ## &copy 复制 ## &quot "
 ## &apos '
 ## &amp &符号 # 3.21 <pre><code class="">a a a a aaefde </code>行内显示代码，不能嵌套 </pre>预留等宽字体 * ol（Ordered List）有序列表,
      ul(Unordered List)，无序列表 * li <ol><li>aaa <ul><li>a1</li><li>a2</li><li>a3</li></ul></li><li>bbb</li><li>ccc</li><li>ddd</li></ol>* dl <dl><dt>导演</dt><dd>张艺谋</dd><dt>主演</dt><dd>张三</dd><dd>李四</dd><dd>王二麻</dd></dl># 表单标签 ## input标签 * 可以交互 <form action="表单提交地址" target="_blank" 本页跳转><input typy="text">文本 <input typy="password">密码 <input typy="checkbox" name="张三">checkbox复选框，默认选中，以name相同分组 <input typy="color">选择颜色 <input typy="radio" name="张三">单选 <input typy="file" accept="jpg,.png>自动选择相应文件格式
 <input typy="file" multiple(可以选多个文件) accept="imamg/png>媒体类型/对应格式
 <input typy="image" 提交按钮 src="xxx.jpg按钮图片>
 <input typy="reset" value="更改按钮的文字">重置按钮 <input typy="subim" value="提交表单">表单提交 <input typy="number">可以输入数字 <input typy="email" name="email">输入邮箱 <input typy="datetime-local">选择时间 <input typy="ual">输入网址 <input typy="range" min="最小值" max="最大值">滑动条 <input placeholder="name" typy="" value="">框内显示输入内容 <input autofucos typy="" name="">有autofucos光标聚焦在此 <input typy="password" name="password">告诉程序是密码 <input typy="text" name="name">告诉程序是名字 <input required typy="email" name="email">有required是必填项否则不能提交 后面加上一个name="" 作为提示信息 自闭和标签input br hr img link meta base button按钮（需要程序配合）可以图片等 input是纯文字 ## label标签 * 扩大文本选择范围 <label><input typy="radio" valua="male男性" name="gender">male <input typy="radio" valua="female女性" name="gender">female </label><form action="表单提交地址" target="_blank" 本页跳转><input typy="subim" value="提交表单"></form>hideen隐藏 * <select name="msjor" multiple(单选是下拉，多选是点击) size="" 增加选项数量><option vaule="数学" hidden（隐藏）>数学</option><option vaule="文学" disabled（无法选择此项）>文学</option><option vaule="CS" selected(自动选择此项)>CS</option><option>数学</option>不写vaule="数学" ，默认文字为选项 </select><fidldest>将此部分框起来 <legend>详细信息</legend><select name="hometown地区"><optgroup label="华中">分组 <option vaule="武汉">武汉</option></optgroup></fidldest></select><table border(边框)="1">表格 <caption>标题</caption><thead><tr><th colspan单元格跨行="2" rowspan单元格跨列="2"></th><td>25</td>换成 <th>25</th>文字加粗 <td>20</td><td>20</td><td>20</td><td>20</td><td>20</td></tr></thead></table><thead>表头 <tfoot>表尾 <tr>标体 <th>1</th><th>2</th><th>3</th><th>4</th></tr></tfoot></thead><th colspan="" rowspan=""></th><thead></thead>只能有一个 <tbody></tbody>可以有多个 <td header=""></td>可以是某个值的ID <th bgcolor="颜色"></th>某一格颜色 <tr bgcolor="颜色"></tr>某一行颜色 在<caption>之后 <colgroup bgcolor="颜色"><col>代表表格第1列 <col>代表表格第2列 <colcolgroup bgcolor="颜色">* map 映射标签 <img src="图片地址" alt="" usemap="#aaaa"><map name="aaaa"><area shape="形状" coords="坐标" href="需要跳转的链接" target="_blank" alt="">rect矩形 circle圆形 polygon多边形 </map>* <iframe src="地址" frameborder="0边框大小"></iframe>一个页面套另一个页面，内联窗口 非自闭和标签 <iframe src="" frameborder="0"><p>你的浏览器不支持frame</p>不支持iframe的网页则显示此文字，备用 </iframe><a href="地址" target="foo5">0000</a>点击foo5在内嵌窗口打开 <iframe src="" name="foo5" frameborder="0"><a href="地址" target="xxx">p5 in xxx</a>xxx=_top顶层窗口 xxx=_self本窗口 xxx=_parten _blank”、“_self”、“_parent”、“_top <frameset rows="尺寸">窗口尺寸 <frame></frameset>< !DOCTYPE html><html><head><meta charset="utf-8"><title>JS Bin</title></head><body><img src="https://travel.12306.cn/imgs/resources/uploadfiles/images/d9ae79de-2f3f-4e9f-ad6e-bdc291dda92a_product_W572_H370.jpg" alt="" usemap="#xibu"><map name="xibu"><area shape="rect" coords="20,17,201,134" href="https://www.jd.com/" target="_blank" alt=""><area shape="circle" coords="286,255,60" href="" alt="" target="_blank"><area shape="polygon" coords="262,29,368,115,570,105,483,17" href="" alt=""><area shape="circle" coords="" href="" alt=""><area shape="polygon" coords="" href="" alt=""><area shape="polygon" coords="" href="" alt=""></map></body></html>## 3.22 <article></article><footer></footer>页面底部 <nav></nav>导航栏 <main></main>主体区域 <template>模板 <p>Lorem <sub>2</sub>ipsum dolor sit,
      amet consectetur adipisicing elit. Ab,
      non.</p><script>此处写代码运行</script><script src="xxx.js"></script>引用其他的代码 <video src="xxx.mp4"></video><video autoplay(自动播放) loop（循环播放） preload（预加载） controls（是否显示进度条）><source src="xxx.mp4">播放相应的格式 <source src="xxx.webm"><source src="xxx.mkv"></video><input type="password">***** <object data="地址" type="媒体类型"></object>可以嵌套网页等 <canvas></canvas>画布需要配合JS <progress value="75"></progress>进度条标签 *** 语义化 合理的嵌套 HTML5 * 是目前为止，所有前端技术集合 * es6,
      css3,
      html * 可访问性accessibility 简称a11y * internationalizition 简写为110n 国际化 * 在各个设备上访问 * <style>p {
        font-size: 12px;
        background: linear-gradient(to right, red, green, blue);
        background-clip: text;
        -o-background-clip: text;
        -ms-background-clip: text;
        -moz-background-clip: text;
        -webkit-background-clip: text;
        color: transparent;
      }

    </style>
    改变文字为透明色，使用背景做渐变色
    <p>这里的文字渐变</p>




    <style>
      p {
        font-size: 12px;
        字体大小 background: linear-gradient(to right, red, green, blue);

        -webkit-background-clip: text;
        color: transparent;
        透明色
      }

    </style>更改<p></p>里面的文字颜色


    ## CSS
    * 层叠 样式 表
    * 写在<style></style>里
    <style>
      * <link rel="stylesheet" href="css文件" media="print打印">@import " xxx.css" 在引用文件里引用

    </style>



    @import
    必须出现在文件头/顶部
    @import " xxx.css"在引用文件里引用



    内联样式



    选择器

    1.标签选择器
    直接在{前面写标签名
    2.类选择器与id选择器

    .aaa选择对应单词的部分
    #single选择对应id的部分


    .aaa {

    }

    <a href="" class="aaa"></a>

    #single{

    }

    <a href="" class="single"></a>


    3.属性选择器
    [href="a.html"]选中href属性的值为a.html的元素
    [href]选中有href属性的元素
    [href^="abc"]选中href属性的值以abc开始的元素
    [href$="abc"]选中href属性的值以abc结尾的元素
    [href*="abc"]选中href属性的值有abc的元素
    [href~="abc"]选中href属性中有abc这个独立单词的元素，基本等价于.aaa选择器
    [class~="abc"]，基本等价于.aaa选择器
    [href|="abc"]选中href属性的值为abc或以abc-开头的元素


    4.伪类选择器，根据元素的隐含信息做出选择
    使用顺序如下：
    :link 未被访问过的链接
    :visited 已被访问过的链接，该选择器内只能选择color属性
    :focus 选中被聚焦的元素（光标所在位置）
    :hover 选中被鼠标悬浮的元素
    :active 选中被鼠标按中的元素



    :link{

    }

    :visited{

    color:red

    }

    :hover{

    border:3px solid red;

    }

    :active{

    .a li:nth-child(n+4):nth-child(-n+7){color: red;}

    }

    5.位置伪类
    :first-child 选中任何元素的第一个子元素
    :last-child 选中任何元素的最后一个子元素
    :nth-child(数字)或(2n+-1奇数高亮)或（even偶数） 选中任何元素的第几个子元素
    :nth-last-child(数字)或(2n+-1奇数高亮)或（odd奇数） 倒着选中任何元素的第几个子元素
    :first-of-type 选中某个元素的子元素中某种类型(此类型指标签名)的第一个
    :nth-of-type(2) 选中某种类型的第2个(此类型指标签名)

    p.foo.bar 三个选择器选中的元素取交集，必须同时满足，选中结果集合
    p.link:hover 复合选择器
    div p div div元素后代代码中的p元素，有div作为祖先的p元素，div里面的p元素
    div main span a img 选中div里面的main标签里面的a里面的img
    div>p 选中div子元素中的p
    div> p a >span 选中div子元素中的p里面的a，a子元素中的span标签，可以继续增加
    div:first-child 选中作为其父元素的第一个子元素的div元素
    div :first-child div后代中的大儿子
    div > :first-child div的第一个子元素
    div~p 选中div后面兄弟元素的p标签，有div作为其前续兄弟元素的p标签
    div+p 选中div后面毗邻的p标签，要求div与p一前一后挨着出现，选中后一个
    , 可以继续写多个选择器
    如
    div h1,h2
    :empty 选中空标签


    :not(a) 取反选择器，选择括号内以外的所有元素

    border:8px solid red;

    }



    * {
    background-color: rgba(0,0,0,0.08);
    box-shadow: inset 0 0 1px red;元素阴影
    }
    html {
    zoom: 2;function zhuanhuanCsv(csvString) {
  var lines = csvString.trim().split('\n')
  var result = []

  lines.forEach(line => {
    result.push( line.split(',') )
  })

  var [head, ...rest] = result

  var objs = []

  for (var item of rest) {
    var obj = {}
    for (var i = 0; i < head.length; i++) {
      obj[  head[i]  ]   =   item[i]
    }
    objs.push(obj)
  }

  return objs
}
14:46:31.778

    }


    在多个选择器选中标签时，
    (类，属性，标签)


    c:\Users\18715\Documents\Tencent Files\1192755230\FileRecv\MobileFile\Image\WH[22`58UWBORGP6}0F134F.png



    700 颜色
    * rgb(r,g,b)
    * rgba(r,g,b,透明度a 0.5)百分比
    * hsl(色相hue,saturate色域,light亮度)
    * hsla(色相hue,saturate色域,light亮度，透明度)


    * 角度 degree 45deg 45°
    -randia弧度 3.14rad=180deg
    -turn 圈
    {
    transform:rotate(180deg)180°(0.25turn)0.25圈
    }

    * url
    *@import url("aaa.css")

    * css 关键字
    * width:300px
    * display: block
    * font-size
    *

    ** 字符串
    * content: 'ffoo\6655'

    *** 长度单位
    * width:20cm/20in英寸/1pt是七十二分之一in/1pc是六分之一in

    *** 相对长度单位
    *px css像素（设计中，大多数认为是绝对长度）
    *
    * em
    * 用在字号上的时候取父元素的字号大小为基础
    * rem 根据根元素上的字号大小改变
    * ch 0字符的宽度
    * ex x字符的高度
    * vw/vh 视口宽高
    div{
    font-size:5px
    background:red;整体字体背景颜色
    width:50vw/vh

    }
    *百分比
    - withd: cala计算(2 * 30em - 40%) / (10px * a0 - 5%/) / (500px - 2em) / (10px * 10px / 10px)运算符两边必须加空格
    -






    *** 字体族
    * font-family:幼圆,宋体,
    * 衬线字体 serif
    * 非衬线字体 sans-serif

    * 字重
    * font-weight:900 字体粗细 100-900之间
    * font-weight:bolder/lighter 比自己父元素粗/细
    * font-weight:normal/bold

    * 字号
    * font-size:5px 字体大小
    * font-style:normal 常规
    * font-style:oblique/italic 正斜体/假斜体
    * font-variant:small-caps 小写字母（改变表现形式，不改变大小）
    * text-transform:; 改变字体大小 capitalize用大写字母,none无改变,


    * 线

    * text-decoration: underline下划线/line-through中划线/overline上划线;
    * text-decoration: underline red(颜色) 10px(粗细) dashed(虚线) solid()

    * text-decoration-thickness(粗细): 10px;
    * text-decoration-color(颜色): blue;
    * text-decoration-style: ;
    * text-decoration-line: ;

    * 阴影

    * text-shadow: 5px(水平偏移) 10px(垂直偏移) 3px(模糊半径) red(颜色);
    * box-shadow:0px(水平偏移) 0px(垂直偏移) 2px(模糊半径) 2px(扩散) red(颜色);

    * white-space: nowrap不换行; 控制空格和空白
    * word-break: keep-all(保留所有单词不折断); 折断


    /* * white-space:pre; 保留代码内原本的格式 */




    * direction: ltr左右/rtl右左; 改变文字书写方向





    *line-height: 80px 行高，一般写无单位的纯数字

    font:[<font-style> || <font-vsrisnt> || <font-weight>] <font-size>[<line-height>] <>;

                p{
                font-size:2em;
                text-indent:2em;(段落缩进)
                }

                text-indent: -99999em; 可以将文字隐藏起来
                text-align: center/justify; 居中/对齐
                text-align-last: right; 最后一行靠右对齐
                vertical-align: ;垂直对齐

                word-spacing: 5px; 字体间隔
                letter-spacing: 20px; 字母之间的间隔

                normal 常规


                * 边距

                * div{
                border: 10px dasged red;
                padding: 15xp; 内边距
                margin: 35px;
                }
                content-box 内容盒子
                padding-box 内边盒子
                border-box 可视盒子
                margin-box 外边距

                content/border/margin/padding- top 上/right 右/bottom 下/left 左:5px
                padding:15px 自动取对边

                p{
                border-top-width:20px;
                border-top-color:blue;
                border-top-style: groove山脊色;

                border-style:solid dotted double dashed;直接确定四边
                border-color: 颜色 颜色 颜色 颜色;
                border-width: 1px 1px 1px 1px;
                所有的都是按照上右下左顺序

                width: 100px; 宽
                height: 150px; 高
                默认设置内容盒子

                box-sizing: content-box/border-box; 可以确定想控制哪个盒子的宽高
                width: 100px; 宽
                height: 150px; 高




                块元素的水平布局：
                水平方向上的七大属性之和要等于其包含块的宽度
                如果有一个为auto：
                则通过包含块的宽度减去其它六个属性计算出这个auto的值
                如果没有auto：
                则将margin-right重置为auto
                如果有两个auto：
                两个auto在margin-left/right上
                则两个auto计算为相同的值，元素相当于定宽居中
                如果有一个auto在width上，则将另一个auto重置为0
                相当于额外的宽度都给到width属性用于显示内容
                如果有三个auto：
                两个margin的auto都被重置为0
                对于从左往右的语言，任何时候，margin-left和width都不能自动被计算为负值
                如果要计算出的时候，用0，多余的负值给到margin-right
                margin-left被指定为负值时，元素会向左往包含块外拉
                margin-right被指定为负值时（未被重置时），元素会向右往包含块外拉

                块元素常见水平布局：
                定宽居中：
                定宽，左右margin为auto
                固定的左右留白，宽度占据额外的空间
                左右margin为指定的留白值，width为auto
                元素居左：
                margin-right为auto
                元素居右：
                margin-left为auto













                * 盒模型，box model
                - 盒模型是什么
                - margin外边距
                + 可以为负值
                + 垂直margin会合并
                + 垂直margin在有些情况下会超出到父元素之外
                + 值的复制
                * margin: a; -> a a a a
                * margin: a b; -> a b a b
                * margin: a b c; -> a b c b
                * margin: a b c d; -> a b c d
                * padding同理
                + margin-left/right/top/bottom
                - border
                + border-width: 3px 5px 2px ;
                * 边框宽度
                + border-color: red green;
                * 默认为color的值
                + border-style: solid dotted dashed double;
                * solid
                * dotted
                * 其它
                + 所有边框可以写在一个属性里面
                * border: style color width;顺序任意
                * border: none
                + 也可以单独设置某一边的边框
                * border-left/top/bottom/right: style color width;
                + 甚至可以完全分开设置任意一边的任意一个属性
                * border-left-width/color/style
                + 画三角形
                * http://jsbin.com/nasolud/1/edit?css,output
                - padding
                + 内边距，不能为负值
                + 背景颜色会显示在padding上面
                - content
                + 内容区域
                - width
                + block类型的元素会占满父元素的水平内容区域
                + 更严格的说，是 margin-left,border-left-width,padding-left,width,padding-right,border-right-width,marign-right
                加起来正好等于父元素内容水平宽度
                * http://jsbin.com/pakege/1/edit?html,css,output
                - box-sizing
                + 宽度的计算方式
                * border-box
                * content-box
                * 没有margin/padding-box
                * 但另一个属性支持这两个选项
                + doctype
                * 在ie低版本下，如果不声明doctype的话，默认为border-box模型


                }

                overflow: auto;超出部分自动

                display:flow-root; 触发BFC

                BFC Block Formatting Context
                块级格式化上下文
                就是一个元素它建立了小宇宙
                手段：3
                overflow: hidden超出部分隐藏/auto/scroll超出部分滚动;
                只要不是visible
                display: flow-root;
                让元素浮动
                让元素定位
                让元素成为行内块
                让元素成为表单元格
                行为：
                封闭了。
                内部元素的margin跑不到外面去
                内部的浮动元素跑不到外面去
                外面的浮动元素跑不到里面来


                list-style:none; 列表样式

                ol>li*20>Lorem30

                a{word$}*60

                width:min/max-content 最小最大宽度


                行内块元素
                从外面看考虑自己的位置时，它就是个行内元素
                从里面看考虑其内容的布局时，或者说它里面的元素，会认为自己处于一个块级元素里

                行内布局：
                确定每行元素的行内框（布局框）
                包裹所有行内框最高点到高低的最小框即为行框
                行框从上往到依次堆叠

                如何确定每种元素的行内框（布局框）
                行内元素包裹的文本，或匿名文本，display: inline;
                看行高值，行高的值决定了它的布局框大小
                还要看其基线，在字号比行高大的情况下，基本可以处于布局框的外面
                行内替换元素,img,input
                布局框为其margin-box
                非要有一个基线的话，margin-box的底部做为其基线
                行内块元素 display:inline-block;
                布局框为其margin-box
                以其内容的最后一行的基线为自己的基线
                当设置了bfc时，则以margin-box的底部为基线
                确定每个元素的垂直偏移
                通过vertical-align属性确定
                top,bottom,middle,baseline
                百分比，基于当前元素行高
                长度值
                确定完相互的偏移，才能确定行框的范围
                如何去掉行内块元素之间的空白
                零字号，但要在后代元素中还原字号
                将这个空白从html代码中去掉
                负margin
                word-spacing为负
                行内元素(display:inline)的content-box的高度是当前字体以及字号的默认行高的高度
                不能通过height属性或才是line-height属性改变它的高度
                只能通过改变字号或字体的方式来改变它的高度



                * 定位布局
                可以直接指定一个元素的位置/坐标
                定位使用position属性触发
                position:fixed/static
                * static 不定位 之前所有看到position的值都是它
                * fixed 固定定位，相对于窗口定位，元素会脱离常规流，即其父元素，后面的兄弟元素感知不到他，当他不存在
                * absolute 绝对定位 会脱离常规流，相对于最近的定了位的祖先的padding-box定位，就是该祖先的padding-box为其包含块
                即position属性不为static
                * ralative 相对定位，不脱离常规流，原来的位置为其保留，相对于自身原来的位置定位
                * sticky 黏粘定位，结合以上三种定位

                ** z-index 设置一个层叠顺序，类型相同后盖前，类型不同定位元素盖住常规流元素
                有z-index时，z-index越大，元素越往上，目前只能用在定位元素上，
                当父子元素都定位时，父元素无法通过z-index覆盖子元素


                定位位置通过 top bottom left right 来指定,不指定的话则在他原本的地方

                伪元素
                <div>
                  aabbaabb(在文字内容前后显示)
                </div>

                div::before{
                content:'foo';
                }前
                div::after{
                content:'foo';
                }后
                在aabbaabb前后显示

                如此显示"foo aabbaabb foo"

                div::before{
                content:attr(属性值);取父元素的属性值
                }


                每个非自闭合元素都有一前一后两个伪元素，相当于该元素的第一个和最后一个子元素
                div:first-child 最终一定选中一个满足特定条件的div
                div::before 选中div的before伪元素

                通过伪元素选择器选中伪元素后必须要设置content属性伪元素才会出现。

                伪元素里面不能再有伪元素了
                伪元素不能被hover
                div::after:hover {无效}
                div:hover::after {有效,当div被hover时，其伪元素如何}
                又由于伪元素不能有后代，所以伪元素如果出现在选择器里，一定是最后一项

                伪元素可以实现的效果几乎都可以通过在html中增加相应的真实元素来实现

                伪元素的内容无法被选中或复制

                伪元素一般用于没有单独交互效果的统一装饰性元素

                伪类与伪元素的区别：
                伪类是真实存在的元素隐含的信息
                伪元素是没在html代码中书写的元素凭空出现


                # 选择器
                * enabled 被启用的可交互元素
                disabled 被禁用的可交互元素

                :enabled 不等价于 :not(:disabled)

                :read-only 匹配内容只能读的元素，包括普通元素
                :read-write 匹配内容可以读写（修改）的元素

                ** :checked 匹配被选中的元素（主要是radio和 checkbox）

                :indeterminate 匹配處於中間狀態的checkbox
                ** :valid 填寫正確的文本框
                ** :invalid 填寫錯誤的文本框

                :required 必填项
                :optional 选填项

                :any-link 匹配任意链接（即有href的a标签）

                :target 目标元素：即id的值为地址栏#后面的内容的元素，或是页面内跳转到的元素
                :target-with 匹配内部有目标的元素
                :focus-within 匹配光标所在元素的祖先们

                :is(div,section,.foo) :is(i,span,em) {

                }
                基本等价于：
                div i,
                div span,
                div em,
                section i,
                section span,
                secion em {

                }

                div:has(>:hover) {
                选中有子元素被hover的div
                }
                div:has(:hover) {
                选中有后代元素被hover的div
                }
                div:has(+:hover) {
                选中后面一个元素被hover的div
                }
                div:has(~:hover) {
                选中后续有兄弟元素被hover的div
                }


                div{
                transiition: 10s; 被属性选择时缓慢变化
                }
                transiition: width 3s, height 10s;

                transiition-porperty:width , height;
                transiition-duration: 3s, 10s; 3s内变宽，10s秒内变宽
                transiition-delay: 2s; 5s;宽等2s变，高等5s变化
                transiition-timing-function: ease缓慢;/linear匀速/ease-in加速/ease-out减速;
                transiition-timing-function:steps (7); 用七个步骤
                transiition-timing-function:cubic-bezier(0.1,0.1,0.1,0.1;)



                input :focus/:valid/:checked
                /*
                transition属性可以设定元素在样式发生变化时，不是突然变到目标状态，而是缓动到目标状态
                transition-property 设定哪些属性要缓动
                transition-duration 设定每个属性缓动的时间长度
                transition-delay 设定每个属性在执行缓前等待的时间，为负值，缓动动画从已经执行了那么久的位置开始播放

                transition-timing-function 设定缓动的距离时间函数图像，默认值为ease，自带ease ease-in ease-out
                ease-in-out,还可以通过cubic-bezier(p1x,p1y,p2x,p2y)的方式指定一条贝塞尔曲线做为其运动曲线，还有steps(n)进行步进式变化

                简写形式为
                transition: width 2s -1s linear, height 5s 2s;
                */
                /* reset.css */
                将常用元素的样式重置为网站所需要的样式

                /* normalize.css */
                将不同浏览器的默认样式差异抹平


                border-radius: 120px; 边框圆角
                aspect-reato:16/9; 比例设置
                cursor: pointer; 鼠标手

                Less
                <script src="https://cdn.jsdelivr.net/npm/less@4"></script>
                写到<p.val type="text/less"></style>后面

                4.4号
                颜色和背景
                currentColor 取前景色
                background-imga:url(图片链接 )

                background-origin:盒子content-box;选择背景盒子

                background-size: 100px/100% 100px/100%;背景尺寸
                background-size: cover/contain; 等比例放大图片/等比例缩小图片 根据盒子

                background-repeat:no-repeat;让图片不重复
                background-repeat-x: repeat;
                background-repeat-y: repeat;
                object-fit: cover/contain; 根据宽高调整
                background-position: right 5px bottom 5px; 调整图片位置，只能调整角落
                background-clip: content-box; 裁剪图片
                -webkit-background-clip: text; 文字处镂空











                /*
                css变量，又称css自定义属性
                即双中划线开头的属性
                目的是为了不跟css自带属性冲突/重叠/重复
                所有的css自定义属性都是自动继承的
                变量的声明就是通过双中划线开头的属性
                变量的使用/引用就是通过var(--variable-name)
                var函数可以有第二个参数，当这个变量不存在时，其将会使用第二个参数
                var函数可以放进calc里参与calc支持的运算

                与sass less变量的区别：
                sass/less的变量会预处理阶段就运算完成，浏览器看到的时候已经没有变量了，已经是计算完成的内容了。所以不能混合单位使用，因为sass/less在处理时根本不知道有些单位的具体值是多少。
                css的变量是浏览器直接支持的，是在运行过程中执行运算的，可以混合单位使用

                */

                * 第九章：颜色与背景
                - color
                + 颜色 前景色（与之对应的则是背景色）
                * 一般画图工具中都有类似对应的图标
                + 默认为黑色
                + 会被子元素继承
                * 所以设定一个元素的颜色，其子元素都将是这个颜色
                - 这是很明显的(#333)
                + 会做为border，text/box-shadow的默认值
                * text-shadow: 2px 3px 3px;
                * box-shadow: 5px 10px 5px ;
                * border: 10px solid;

                + css3的currentColor
                * 用在其它属性上比如bgc上，或者linear-gradient等
                - background
                + background-color
                * 背景色
                - 默认值为 transparent ，即透明
                * 不继承
                - 否则会有奇怪的效果，比如如果设置了semi透明颜色，而且又继承的话。。
                + background-image
                * url()
                * 默认从padding box开始渲染（画）的
                * 背景图片无法从网页上直接复制
                + background-size
                * https://developer.mozilla.org/en-US/docs/Web/CSS/background-size#Browser_compatibility
                * cover 图片由无穷大缩小到正好覆盖元素
                * contain 图片由无穷小放大到正好被元素包围
                - object-fit 用在图片/视频元素上的css属性
                + img
                + video等
                * 如果attachment为fixed，背景区为浏览器可视区（即视口），不包括滚动条。不能为负值。
                + background-repeat
                * background-repeat
                - repeat
                - repeat-x/y
                - no-repeat
                + background-origin css3
                * content-box
                * padding-box
                * border-box
                * 与box-sizing的关键字是对应的
                + backgorund-attachment
                * scroll 相对于元素自身不动
                * local 相对于元素的内容不动
                * 为此值时bg-size的百分比以元素内容的大小来计算
                * fixed 相对于视口不动
                - 为此值时bg-size的百分比以浏览器窗口的大小来计算
                - 可以用来做视差滚动
                - http://www.mi.com/xiaoyi/?cfrom=list
                + background-position
                * background-position-x/y
                * 雪碧图，css sprite
                * 0 0
                * center 200px
                * 100px
                * 0px 10px 相对于左上角
                * 50% 30% 相对于左上角
                * top left /// right bottom 让图片处于某个角落
                * top 20px right 50px 相对于右上角，往元素中心水平偏50px，垂直偏移20px
                * calc(100% - 50px) 从最右往多偏移50px
                + background-clip
                * xx-box
                * 平铺以后再裁剪
                + -webkit-background-clip
                * text
                + css3 多背景
                * 分开写，合并写
                + background: <bg-img> <bg-repeat> <bg-origin> <bg-size> / <bt-pos> , <bg-img> <bg-repeat> <bg-origin>
                                <bg-clip>, <bg-img> <bg-repeat> <bg-origin> <bg-clip> bg-color;
  + 应用
  * 伪元素里的图片，
  * css sprite
  * 动画，菜单，小米网首页logo动画
  * 视差滚动：小蚁摄像机页面效果，Nike活动页面效果
  * 多背景做花纹







  color: transparent; 文字透明












  text-indent: 20px;段落缩进



  4.6号
  浮动和定位
  书本289页
  css
  float:left/right
  opacity: 0.5; 透明50%

  html
  <img src="" algin="left/right">

  块级元素会当浮动元素不存在
  行内元素会绕着浮动元素渲染

  不同情况下的包含块
  常规流:离其最近的块级祖先
  定位:是其相对定位的祖先块
  浮动:同常规流

  浮动和定位一起用，只有position: relative;时会起作用,其他情况是浮动


  清除浮动:某个块框通过向下移动，使其两边没有浮动元素
  闭合浮动:某个块框通过增加自己的高度使其能够包含其浮动的后代元素(通过自己变大，使所有后代浮动元素被自己包起来)
  】

  清除浮动的元素的border-box避开浮动元素的margin-box


  ** BFC元素:
  行为:
  对于行内块,是让元素的最底部成为基线
  对于受浮动元素的影响的元素,水平方向收缩以避开浮动元素
  当它是定宽时且空间不够时就是下移
  可以利用这个特点实现元素的宽度占据包含块的剩余水平空间
  对于常规流块元素,是margin不跑到自己的外面去
  不管是哪一种,最终都是让内外的布局元素不相互影响
  类似于让元素的边缘成为一个结界,让元素内部成为一个小宇宙/独立的布局空间/布局上下文
  如何触发:
  display: flow-root;
  overflow: scroll/hidden/auto;
  float: left/right;
  position: absolute/fixed;
  表单元格


  闭合浮动的办法:
  触发包含块的BFC
  直接给包含块设定高度
  在元素的最后放一个块元素并清除这个块元素两边的浮动元素
  于是该元素就会下移,顺便把包含块撑高了
  由于总是使用最后一个元素,所以可以伪元素





  * {
  background-color: rgba(0,0,0,0,08);
  box-shadow: inset 0 0 1px red;
  }

  https://jsbin.com/rurafuhafa/2/edit?html,css,output
  导航栏与不同页面区域颜色不同但能随着滚动改变颜色

  clip-path: ; 不限制元素的定位类型，不能裁剪不以当前元素为包含块的元素
  clip-path: polygon(10% 10% 10% 10% 10% 10%);百分比取自身的尺寸，而非包含块的尺寸





  ## flex布局
  大号的行内布局
  flex是内部布局

  普通块元素里的flex元素的外在表现就像一个块一样
  flex-grow: 1;收缩
  flex-skrink: 1;扩张
  flex-wrap: wrap;收缩扩张在折行
  justify-content: start开始方向/end结束方向/content居中/space-between/space-around;
  align-content: flex-start每一行的内容分配在交叉轴上/space-around设定主轴方向上/space-between;
  align-items: ;
  flex-direction: column-reverse;列
  flex-wrap: wrap-reverse;行
  flex-flow: column;
  flex-basis

  <section>
    <div class="a1"></div>
    <div class="a2"></div>
    <div class="a3"></div>
  </section>

  section{
  display: flex;
  margin: auto;
  width: ;
  height: ;
  justify-content: start开始方向/end结束方向/center居中/space-between/space-around;
  align-content: flex-start每一行的内容分配在交叉轴上/space-around设定主轴方向上/space-between;
  flex-grow: 1;占满剩下的空间
  flex-skrink: 1;
  }



  /*

  overflow行为的冒泡
  在特定情况下，给body或html元素设置overflow属性，相当于给视口设置
  所以此时给body设置overflow hidden相当于让视口不出现滚动条，即使有内容在视口以外
  背景颜色同
  给html元素设置bgc或ov就相当于给视口
  而在html元素未设定这两个属性时，给body设置就相当于给html元素设置

  */
  /* Flex布局

  “大号的行内布局”
  flex布局是内部布局

  普通块元素里的flex元素的外在表现就像一个块一样

  扩张与收缩是发生在折行之后
  所以无论如何设定grow与shrink,都不会改变元素在不同行之间的分配
  折行之后不会发生收缩,因为空间不够就折行了,除非一行的唯一一个元素比包含块宽


  justify-content: space-between|space-around|start|end|center;
  设定主轴方向上额外空间的分配,当额外空间没被元素扩张占满时才有效,在在grow之后才生效

  align-content: space-between|space-around|stretch|start|end|center;
  设定交叉轴方向上额外空间如何分配给flex"行"

  align-items: stretch|start|end|center;
  设定每个flex子元素在"行"中的垂直摆放

  1
  设定给flex子元素,单独调整这个元素在flex"行"中的垂直摆放,取值跟align-items一样

  flex-basis: ;
  当主轴水平时,它代表宽度,如果此时也设定了元素的宽度,那只要flex-basis不是auto就是flex-basis生效,否则就是高度生效
  当主轴垂直时,它代表高度,如果此时也设定了元素的高度,那只要flex-basis不是auto就是flex-basis生效,否则就是高度生效

  flex-flow: ;一次性设定flex-direction和flex-wrap;
  flex: ;一次性设定flex-grow, flex-shrink, flex-basis;
  flex: auto|1|500px|none;
  gap: ; 设定flex子元素之间的间隙
  row-gap: ;
  column-gap: ;

  order: number; 设定flex子元素的布局顺序


  flex子元素可以直接使用z-index,在负margin让它们重叠的时候

  flex子元素不能浮动,因为浮动需要发生在普通块/行内上下文里
  flex父元素可以认为触发了bfc,会水平方向避开浮动元素

  主轴垂直时,想要让元素折行,需要给flex父元素定高

  flex子元素auto的margin会被计算为相同的,即便是垂直方向上,但是左和上还是不能计算为负值

  flex父元素中的匿名文本,可以想象成被标签包起来,成为一整个flex子元素


  额外空间的分配:
  首先分给flex-grow的元素,然后分给相应方向上auto的margin,再然后才是留白


  */



  div{accent-color: red;} 更改CheckBox的颜色
  0.0

  :empty 隐藏
  empty-cells: hide隐藏/show显示;
  border-collapse: collapse合并单元格/separate拆分;

  1
  table:has(:is(td,th):nth-child(1):hover) :is(td,th):nth-child(1),
  table:has(:is(td,th):nth-child(2):hover) :is(td,th):nth-child(2),
  table:has(:is(td,th):nth-child(3):hover) :is(td,th):nth-child(3),
  table:has(:is(td,th):nth-child(4):hover) :is(td,th):nth-child(4),
  table:has(:is(td,th):nth-child(5):hover) :is(td,th):nth-child(5),
  table:has(:is(td,th):nth-child(6):hover) :is(td,th):nth-child(6),
  table:has(:is(td,th):nth-child(7):hover) :is(td,th):nth-child(7) {
  background-color: yellow;
  color: red;
  }
  表格列高亮

  方案2
  td:hover::before {
  content: 'aaa';
  position: absolute;
  width: 100%;
  height: 9999px;
  top: -888px;
  background-color: yellow;
  z-index: -5;
  }


  /*
  caption-side: top/bottom;
  设定表格标题的位置，是表格的上方还是下方
  border-spacing: 10px 5px;
  empty-cells: hide;
  border-collapse: collapse/separate;

  table-layout: auto/fixed;
  设定表的尺寸计算模式


  */




  li::first-letter{
  更改首个单词
  }
  li::first-line{
  更改第一行
  }

  input::placeholder{

  }

  <input type="range">
  input[type="range"]::-webkit-slider-runnable-traack{
  滑动按钮形状
  }
  ::-webkit-scrollbar 滚动条滑轨
  ::-webkit-scrollbar-thumb 滚动条滑块
  ::-webkit-scrollbar-button 滚动条上下左右的按钮


  *::selection{
  选中部分的背景字体颜色
  }

  html{
  quotes:'<' '>' '《' '》' ;伪元素的引号 } <span>

    </span><span></span><span></span><span></span><span></span>


    <span></span>
    <em></em>
    <span></span>
    <em></em>
    <span></span>
    <em></em>

    span{
    counter-increment: x y;
    }
    em{
      counter-increment: y;
    }
    span::before{
      content: counter(x) '.' content: counter(y);
    }


    body{
      counter-reset: number 0; 遇到这个标签重置计数器
    }


    p {
 overflow: hidden;
 text-overflow: ellipsis;
 white-space: nowrap;
}单行文本超出省略...


-webkit-line-clamp: 3;
多行文本最后一行显示为省略号
https://developer.mozilla.org/zh-CN/docs/Web/CSS/-webkit-line-clamp

text-align-last: keyword;最后一行的文字方式


grid
grid-template-columns列/rows行: 20% 60% 20% 1fr 2fr剩下空间的几份;设定grid的分区
grid-row/column: 2 / span 2;
grid-area: row-start column-start /row-end column-end;简写
grid-template-columns: 1fr repeat(11, 10px 1fr);重复11次
grid-template-columns: 1fr repeat(auto-fill/fit, 50px;)每列50px,自动适配列的数量
grid-template-columns: 1fr repeat(auto-fill, minmax(50px 1fr) );每列最少50px,自动均分剩下的空间
grid-template-columns: 1fr repeat(auto-fit, minmax(50px 1fr) );每列最少50px,但是没有元素的列宽折叠发错为0

/*
grid布局
设置display:grid;的元素就称为grid容器
grid容器的子元素自动就成为了grid元素
grid上下文的元素不能浮动, 浮动元素只能存在于块级上下文中

grid布局是二维布局
其它的布局都是一维布局

grid子元素也可以直接使用z-index
grid子元素的包含块不是父元素自身，而是其所在cell
grid子元素也可以使用order来调整自己的布局顺序

grid-column-start: 2; 设置子元素列的开始
grid-column-end: span 2;设置子元素列的结束,span n表示跨越多少列
grid-column: 2 / -2; 以上两个属性的简写

grid-row-start: 2;
grid-row-end: span 3;
grid-row: 2 / span 3;


grid-template-columns: repeat(auto-fit, 50px);
每列50px,自动适配列的数量

grid-template-columns: repeat(auto-fit,  minmax(50px, 1fr)  );
每列至少50px,均分剩下的空间

repeat(auto-fill,  minmax(50px, 1fr)  );
每列至少50px
即如果容器宽800,这几乎等价于:
1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr

repeat(auto-fit,  minmax(50px, 1fr)  );
即如果容器宽800,这几乎等价于(当后三列没有元素时):
1fr 1fr 1fr 1fr 1fr 0fr 0fr 0fr


每列至少50px,但是没有元素的列宽度将会被折叠为0,这些宽度给到其他列.

grid-auto-rows: 100px;
由于元素过多造成增加的行的高度
当grid-auto-flow为row时生效

grid-auto-columns: 80px;
由于元素过多造成增加的列的宽度
当grid-auto-flow为column时生效

grid-auto-flow: column/row [dense];
设定元素的流向是“从左往右再从上到下”还是“从上到下再
从左往右”
增加一个dense的效果是，后续的元素可以排到前面元素太大而空出的位置


align-items: ;
控制每个item在cell中的垂直位置
justify-items: ;
控制每个item在cell中的水平位置
简单属性：place-items:;

justify-content:
统一控制子元素的justify-self
align-content:
控制垂直方向额外空间如何分配的
简单属性：place-content:;

align-self: ;
单独设定item在cell中的垂直摆放
justify-self: end;
单独设定item在cell中的水平摆放
简单属性：place-self:;

*/

span{a$}.a$*10

https://kekee000.github.io/fonteditor/在线字体编辑器

字体图标的优缺点
    优点：
      矢量图，放大不会有锯齿效果
      颜色可以随意改变（但是图标整体只能是一个颜色）
      体积小（比css sprite图片体积小）
    缺点：
      图标整体只能是一个颜色
      没有动画


      画图

       <circle cx="30" cy="40" r="20" fill="lightpink" stroke="black" stroke-width="1"></circle>
  <rect x="110" y="80" width="100" height="50" fill="lightblue" stroke="black" stroke-width="1" rx="20"></rect>
   <polygon points="100,10 110, 10 130,50 150,10"></polygon>

  <path d="m10,20l50,80l60,20v60h50a30 10 46 1 1 250 100 60c280 100 280 130 150 150 s20 130 40 120z x20 200l250 250" stroke="red"></path>

      <path d="M10,20 L50,80 L60,20 V80 H70" stroke="black"></path>


      svg图标的用法：
  使用svg的use标签直接引用处于统一的svg标签内的一个symbol对应的图形
    <svg>
      <use xlink:href="#foo"></use>
    </svg>+
  引用来源是当前页面的另一个svg的后代元素
  用法可以参考阿里巴巴图标库网站下载的素材代码
  也可以改颜色
  可以各种特效动画

优点：
  彩色，动画 矢量图，放大不失真，无锯齿效果
  体积小，容量大
缺点：
    不太好用
    因为用的地方要重新把svg标签和里面的use再写一遍
      不过这个问题可以通过一些库等方案解决
        最好让我们书写时只写 <Icon name="cog"/>
    为了兼容性，要在需要用到这些图标的页面内都直接嵌入相应svg文件的源代码
    由于每个页面都分别嵌入，所以会有浪费流量的情况


    div {
       transform: rotate(1dge角度/弧度);
      }

      scale水平翻转
      h2.transform-1 { transform: scale(0.5); }
      h2.transform-2 { transform: scaleX(0.5); }
      h2.transform-3 { transform: scale(1,-1); }


      skew倾斜
      h2.transform-1 { transform: skewX(15deg); }
      h2.transform-2 { transform: skewY(5deg); }
      h2.transform-3 { transform: skewX(15deg) skewY(-15deg); }

      https://jsbin.com/sorozerefe/edit?html,css,output



      column-count: 2;两列
      column-width: 130px;每列最少130
      column-rule: 3px solid red ;设置每列分割线的样式






      border-radius: 50px;边框圆角·

      opacity: 0.5; 透明度


      background-repeat: no-repeat;背景不重复
      background-image: linear-gradient(black 20px/20%, white)矩形背景渐变色
      background-image: linear-gradient(black 20px/20%, white ,transparent 50% 透明)
      background-image: radial-gradient(black, white, red)圆形渐变
      radial-gradient(circle to 0% 0%,black, white, red)控制圆心的变化

      conic-gradient: ;圆心旋转的过程中渐变








      background-color: rgba(243, 240, 240, 0.8);







pc端布局：
  由于电脑屏幕很大，而且一般也不考虑用户把窗口缩小的情况
  页面一般只使用很大屏幕中间一部分，如1226px宽（小米），1192px宽（淘宝），1500px/1200px（alibaba.com）
  开发这种网站的时候，不用考虑太多，直接把主体宽度在窗口居中即可，开发时一般使用像素单位
    不同大小的屏幕会有不同的留白，一般来说屏幕越大留白越多
    一些网站也会使用一些media query来让页面在不同大小的屏幕上适配，但一般只适配两到三种情况
  一般都使用像素单位（即代码中使用px）来开发，而像素单位往往是从设计图中测量得到的

移动端布局：
  由于手机屏幕相对于电脑显示器都很小，所以不能只使用屏幕中间一部分，而往往是占满手机屏幕宽度
  不同的手机有不同分辨率和物理尺寸
  手机（任何浏览器）浏览器在显示一网页的时候，总得有一个初始窗口大小（初始包含块的大小）
    另一个问题是手机上浏览器的窗口大小是不同调节的，双指捏合时的放大并不涉及页面的重新布局
  那么当手机浏览器显示一个页面时，初始包含块宽度是多少？？？？？？？
    是不是手机屏幕的水平分辨率？？？不是。
    通过使用一张图片做为标尺，可以很容易的知道手机浏览器初始包含块的宽度
      最常见的值为980px。也有1024px，960px，1000px。
        手机屏幕那么小，为什么要使用980px的初始包含块呢？？？
          因为用这个宽度做为初始包含块能够正确显示99%已经存在的网站。
            因为在手机浏览器刚刚出来的时候，网站都是设计给pc的。
              而那个时候的网站主体宽度都是950左右，在典型的pc显示器上都能正确显示
  能否改变手机浏览器渲染页面时的初始包含块宽度呢？
    可以。
      通过在head标签中增加
        <meta name="viewport" content="width=1200">
        <meta name="viewport" content="width=device-width">
      可以改变手机浏览器的初始包含块
        该声明只会被手机浏览器识别并使用
          在pc上，初始包含块由窗口大小确定，并且会随着窗口大小的变化而实时变化
      这声明里的宽度可以写的比手机物理分辨率还要大
        可以理解为手机分辨率为无穷大。
      此声明在Android5.0以上是支持写成数值的，写多少就是多少。
      但是在更旧的手机浏览器上，只能写为device-width，写为此值时，在不同的手机上分别对应不同的大小
        常见值为
          360，375，400，415
        而且这个值在同品牌的手机上一般会随着屏幕物理尺寸的变大而变大
  所以在不支持viewport直接写为数值的时候，手机网页面对的是各种大小不一的初始包含块，即浏览器窗口。
    其实pc网页也一样，但是，pc上窗口足够大，我们只使用中间一部分。
  然而由于手机屏幕太小，我们不能只使用中间的一部分，而是要占满其宽度，而这个宽度又各不相同
    同时，每回的设计稿又各不相同（主要是指宽度）
      有些设计师不懂上面这一坨，会用自己手机分辨率来出设计图。
        就算他懂，也只能使用某一个特定的分辨率出设计图。
  就带来了移动端布局的问题。
    问题就是，设计稿宽度是x，浏览器窗口宽度为y，这两者大概率不相同
      而我们还要让设计稿充满浏览器窗口。
    比如，视口宽度为400，设计图为1080宽，

  如果是在现代手机/浏览器上，可以直接通过viewport声明将视口调为1080宽。
    则可以直接使用设计图中测量出来的像素，并加以px单位，即可写入代码中
  但如果要兼容旧的手机/浏览器，viewport声明是无法指定窗口为某个宽度的
    不可行方案一：
      将设计图缩小或放大到正好跟视口宽度一样。
        设计图被放大或缩小后，一些边缘会模糊，无法测量
        不同手机视口宽度不一样
    不可行方案二：
      将设计图缩放为100的整数倍的宽度如1000
        然后测量出400就用40vw写进代码，即可保证在不同设备上的还原
          所有的长度单位都使用vw
        但缩放之后一些地方的边缘会模糊，尺寸不好测量
    方案三：
      使用rem单位，假设设计图宽度为X，则Xrem需要等于窗口宽度，即100vw
        Xrem = 100vw
        1rem = 100vw / X
        html { font-size: calc(100vw / X) }
      通过这样的设置，即不用缩放设计图，也不用关心视口的宽度的像素单位
      设计图中测量出来的试试直接加上rem单位即可用在代码中
      存在的问题：
        连设置viewport为数值都不支持的浏览器，甚至连calc都不支持
          用js，读取视口的像素单位计算并设置到html元素上
        该公式读出来的字号可能会很小（约3px左右）
          而一些浏览器默认限制了能使用的最小字号为12px。
            所以设置的太小就会被重置为12px。
          所以往往是这样设置：
            html { font-size: calc(100vw / X * 100) }
          测量的出来的尺寸移动一两个小数点即可直接用在代码里。
    方案四：
      直接设置viewport为设计图的宽度，然后使用px单位来开发。

    实际上上面的四种方案都不属于“设计上”的正确。
      因为我们并不需要屏幕越大按钮越大字越大，而需要屏幕越大字越多
      所以最“正确”的做法应该是使用device-width的viewport宽度，使用像素单位开发，页面中的内容都是“流式”的
        但这样的设计有时不能或无法体现设计师的意图
        另一方面是这种流式设计的页面比较难以实现





          3D transform

          transform: 景深perspective视角距离(80px) rotatex/y/z三个轴方向的旋转角度(30deg);
          transform: rotatex(30deg) rotatey(30deg) rotatez(30deg);
          transform: rotate3d( x, y, z,30deg)

          transform:; translate(translateX/Y/Z);平移

          transform: perspective-origin: 50% center;视角位置
          transform-style: preserve-3d;显示3d
          backface-visibility: hidden;背面能见度


  section {
    transform: perspective(var(--pers)) rotatex(0deg) rotatey(45deg);
  }
  .a1 {
    --pers: 100px;
  }
  .a2 {
    --pers: 500px;

  }
  .a3 {
    --pers: 1000px;

  }


  &nbsp;


  <div>
    Lorem ipsum, dolor sit amet consectetur adipisicing elit. Corporis, dignissimos.
    </div>

    @keyframes spin{

        form{

        }
        to{

        }
        0%{

        }
        10%{

        }
        50%{

        }

    }
    @keyframes expand {
       from { border-width: 4px; }
       50% { border-width: 12px; }
       to {
       border-width: 4px;
       height: 100%;
       width: 100%;
 }
}

    div{
      animation-name: spin ;动画名称
      animation-duration: 5s;动画持续时间
      animation-timing-function: linear 匀速/ease 缓慢;
      animation-delay: 0s;动画延迟
      animation-iteration-count: 8;动画重复次数,动画迭代次数
      animation-direction: alternate-reverse 反向;动画方向
      animation-fill-mode: forwards   backwards;动画填充模式
      animation-play-state: paused; 动画播放状态：暂停；



    集合  animation: name duration timing-function delay iteration-count direction fill-mode play-state;
    }
    /*
animation-play-state:
running 默认值，即播放状态
paused 暂停状态

animation-iteration-count: 2;
动画播放次数，infinite表示无数次

animation-direction: normal;
动画播放方向
normal 每次都正向播放
reverse 每次都反向播放
alternate 一正一反
alternate-reverse 一反一正

animation-fill-mode
none 播放前和播放完成后都保持自己的样式而不动画的首帧状态
backwards 动画播放之前元素就显示为动画第一帧的样子，所以需要跟延迟一起使用，动画已经加到元素上，但处于delay状态
forwards 动画播放完成之后（所以动画不能播放无数次）元素保持最后一帧的样子
both 以上两者的共同效果
*/


<script>



### 运动轨迹显示
var div = $0 // 获取要显示轨迹的元素

setInterval(() => {
  var pos = div.getBoundingClientRect() // 获取元素相对于视口的位置信息
  var dot = document.createElement('div') // 创建表示运动轨迹的点元素

  dot.style = `
    position: fixed;
    width: 2px;
    height: 2px;
    background: red;
    top: ${pos.top}px; // 将点的纵坐标设置为元素相对于视口的顶部位置
    left: ${pos.left}px; // 将点的横坐标设置为元素相对于视口的左侧位置
  `

  document.body.append(dot) // 将点元素添加到文档的 body 元素中

}, 100)



       filter: blur(10px);模糊(10px)
       filter: brightness(50%);亮度(50%)
       filter: contrast(50%);对比度(50%)
       filter: grayscale(100%);灰度(100%)
       filter: sepia(100%);棕褐色(100%)
       filter: saturate(200%);饱和(200%)
       filter: hue-rotate(45deg);色调旋转(45度)
       filter: opacity(25%);不透明度(25%)
       filter: drop-shadow(5px 5px 3px gray);阴影
       shape-outside: circle(100px at left top);外部形状：圆形



       div {        width: 256px;
        height: 256px;
        background-blend-mode: screen;
        background-image:
         linear-gradient(to right,rgb(0,255,255),rgba(0,255,0)),

         linear-gradient(to bottom,rgba(0,255,0),rgb(255,255,0));
    }        使用混合模式叠加出rgb色彩空间的一个面

    现代css里元素可以感知自己容器的大小来改变自己的布局

    container query




    user-select: none;让文字无法被鼠标选中
    pointer-events: none; 让元素完全不可跟鼠标交互，可以用来做水印
